[
  {
    "objectID": "pmotools-python-usages/getting_basic_info_from_pmo.html",
    "href": "pmotools-python-usages/getting_basic_info_from_pmo.html",
    "title": "Getting basic info out of PMO using pmotools-python",
    "section": "",
    "text": "To get simple counts of number of targets with sample counts, samples with target counts, the counts of meta fields\nMost of these basic info extractor can be found underneath extract_basic_info_from_pmo\n\nCodepmotools-runner.py\n\n\n\n\npmotools v1.0.0 - A suite of tools for interacting with Portable Microhaplotype Object (pmo) file format\n\nAvailable functions are\nconvertors_to_json\n    text_meta_to_json_meta - Convert text file meta to JSON Meta\n    excel_meta_to_json_meta - Convert excel file meta to JSON Meta\n    microhaplotype_table_to_json_file - Convert microhaplotype table to JSON Meta\n    terra_amp_output_to_json - Convert terra output table to JSON seq table\nextractors_from_pmo\n    extract_pmo_with_selected_meta - Extract from PMO samples and associated haplotypes with selected meta\n    extract_pmo_with_select_specimen_ids - Extract from PMO specific samples from the specimens table\n    extract_pmo_with_select_experiment_sample_ids - Extract from PMO specific experiment sample ids from the experiment_info table\n    extract_pmo_with_select_targets - Extract from PMO specific targets\n    extract_allele_table - Extract allele tables which can be as used as input to such tools as dcifer or moire\nworking_with_multiple_pmos\n    combine_pmos - Combine multiple pmos of the same panel into a single pmo\nextract_basic_info_from_pmo\n    list_experiment_sample_ids_per_specimen_id - Each specimen_id can have multiple experiment_sample_ids, list out all in a PMO\n    list_specimen_meta_fields - List out the specimen meta fields in the specimen_info section\n    list_tar_amp_bioinformatics_info_ids - List out all the tar_amp_bioinformatics_info_ids in a PMO file\n    count_specimen_meta - Count the values of specific specimen meta fields in the specimen_info section\n    count_targets_per_sample - Count the number of targets per sample\n    count_samples_per_target - Count the number of samples per target\n\n\nGetting files for examples\n\nCodecd example \n\nwget https://seekdeep.brown.edu/Portable_Microhaplotype_Object/format/moz2018_PMO.json.gz\nwget https://seekdeep.brown.edu/Portable_Microhaplotype_Object/format/PathWeaverHeome1_PMO.json.gz\n\n\n\nThis will list all the meta fields within the specimen_infos section of a PMO file. Since not all meta fields are always present in all specimens, this will list the count of samples each field appears in and the number of total specimens\n\nCodepmotools-runner.py list_specimen_meta_fields -h \n\nusage: pmotools-runner.py list_specimen_meta_fields [-h] --file FILE\n                                                    [--output OUTPUT]\n                                                    [--delim DELIM]\n                                                    [--overwrite]\n\noptions:\n  -h, --help       show this help message and exit\n  --file FILE      PMO file\n  --output OUTPUT  output file\n  --delim DELIM    the delimiter of the output text file, examples input\n                   tab,comma but can also be the actual delimiter\n  --overwrite      If output file exists, overwrite it\n\n\nThe python code for list_specimen_meta_fields script is below\n\n\nCode\npmotools-python/scripts/extract_info_from_pmo/list_specimen_meta_fields.py\n\n#!/usr/bin/env python3\nimport os, argparse, json\nimport sys\nfrom collections import defaultdict\n\nimport pandas as pd\n\nfrom pmotools.pmo_utils.PMOExtractor import PMOExtractor\nfrom pmotools.pmo_utils.PMOReader import PMOReader\nfrom pmotools.utils.small_utils import Utils\n\n\ndef parse_args_list_specimen_meta_fields():\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--file', type=str, required=True, help='PMO file')\n    parser.add_argument('--output', type=str, default=\"STDOUT\", required=False, help='output file')\n    parser.add_argument('--delim', default=\"tab\", type=str, required=False, help='the delimiter of the output text file, examples input tab,comma but can also be the actual delimiter')\n    parser.add_argument('--overwrite', action = 'store_true', help='If output file exists, overwrite it')\n\n    return parser.parse_args()\n\ndef list_specimen_meta_fields():\n    args = parse_args_list_specimen_meta_fields()\n\n    # check files\n    output_delim, output_extension = Utils.process_delimiter_and_output_extension(args.delim, gzip=args.output.endswith(\".gz\"))\n    args.output = args.output if \"STDOUT\" == args.output else Utils.appendStrAsNeeded(args.output, output_extension)\n    Utils.inputOutputFileCheck(args.file, args.output, args.overwrite)\n\n    # read in PMO\n    pmo = PMOReader.read_in_pmo(args.file)\n\n    # count fields\n    counts_df = PMOExtractor.count_specimen_meta_fields(pmo)\n\n    # output\n    counts_df.to_csv(sys.stdout if \"STDOUT\" == args.output else args.output, sep = output_delim, index=False)\n\nif __name__ == \"__main__\":\n    list_specimen_meta_fields()\n\n\n\n\nCodecd example \npmotools-runner.py list_specimen_meta_fields --file moz2018_PMO.json.gz\n\nfield   presentInSpecimensCount totalSpecimenCount\ncollection_country  124 124\ncollection_date 124 124\ncollector   124 124\ngeo_admin3  124 124\nhost_taxon_id   124 124\nlat_lon 124 124\nparasite_density    124 124\nplate_col   81  124\nplate_name  81  124\nplate_row   81  124\nproject_name    124 124\nsamp_collect_device 124 124\nsamp_store_loc  124 124\nsamp_taxon_id   124 124\nspecimen_id 124 124\n\n\n\nCodecd example \npmotools-runner.py list_specimen_meta_fields --file moz2018_PMO.json.gz --output spec_fields_moz2018_PMO.tsv --overwrite\n\n\n\nThis will list all the meta values (and the combinations) for the meta fields within the specimen_infos section of a PMO file.\n\nCodepmotools-runner.py count_specimen_meta -h \n\nusage: pmotools-runner.py count_specimen_meta [-h] --file FILE\n                                              [--output OUTPUT]\n                                              [--delim DELIM] [--overwrite]\n                                              --meta_fields META_FIELDS\n\noptions:\n  -h, --help            show this help message and exit\n  --file FILE           PMO file\n  --output OUTPUT       output file\n  --delim DELIM         the delimiter of the output text file, examples input\n                        tab,comma but can also be the actual delimiter\n  --overwrite           If output file exists, overwrite it\n  --meta_fields META_FIELDS\n                        the fields to count the subfields of, can supply\n                        multiple separated by commas, e.g. --meta_fields\n                        collection_country,collection_date\n\n\nThe python code for count_specimen_meta script is below\n\n\nCode\npmotools-python/scripts/extract_info_from_pmo/count_specimen_meta.py\n\n#!/usr/bin/env python3\nimport os, argparse, json\nimport sys\nfrom collections import defaultdict\n\nimport pandas as pd\n\nfrom pmotools.pmo_utils.PMOExtractor import PMOExtractor\nfrom pmotools.pmo_utils.PMOReader import PMOReader\nfrom pmotools.utils.small_utils import Utils\n\n\ndef parse_args_count_specimen_meta():\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--file', type=str, required=True, help='PMO file')\n    parser.add_argument('--output', type=str, default=\"STDOUT\", required=False, help='output file')\n    parser.add_argument('--delim', default=\"tab\", type=str, required=False, help='the delimiter of the output text file, examples input tab,comma but can also be the actual delimiter')\n    parser.add_argument('--overwrite', action='store_true', help='If output file exists, overwrite it')\n    parser.add_argument('--meta_fields', type=str, required=True, help='the fields to count the subfields of, can supply multiple separated by commas, e.g. --meta_fields collection_country,collection_date')\n\n    return parser.parse_args()\n\n\ndef count_specimen_meta():\n    args = parse_args_count_specimen_meta()\n\n    # check files\n    output_delim, output_extension = Utils.process_delimiter_and_output_extension(args.delim, gzip=args.output.endswith(\".gz\"))\n    args.output = args.output if \"STDOUT\" == args.output else Utils.appendStrAsNeeded(args.output, output_extension)\n    Utils.inputOutputFileCheck(args.file, args.output, args.overwrite)\n\n    # process the meta_fields argument\n    meta_fields_toks = args.meta_fields.split(',')\n\n    # read in PMO\n    pmo = PMOReader.read_in_pmo(args.file)\n\n    # count sub-fields\n    counts_df = PMOExtractor.count_specimen_meta_subfields(pmo, meta_fields_toks)\n\n    #write out\n    counts_df.to_csv(sys.stdout if \"STDOUT\" == args.output else args.output, sep = output_delim, index=False)\n\n\nif __name__ == \"__main__\":\n    count_specimen_meta()\n\n\n\n\nCodecd example \npmotools-runner.py count_specimen_meta --file moz2018_PMO.json.gz --meta_fields collection_country\n\ncollection_country  specimensCount  specimensFreq   totalSpecimenCount\nMozambique  81  0.6532258064516129  124\nNA  43  0.3467741935483871  124\n\n\n\nCodecd example \npmotools-runner.py count_specimen_meta --file moz2018_PMO.json.gz --meta_fields collection_country --overwrite --output collection_country_count_moz2018_PMO.tsv.gz \n\n\n\nCodecd example \npmotools-runner.py count_specimen_meta --file moz2018_PMO.json.gz --meta_fields collection_country,geo_admin3\n\ncollection_country  geo_admin3  specimensCount  specimensFreq   totalSpecimenCount\nMozambique  Inhassoro   27  0.21774193548387097 124\nMozambique  Mandlakazi  28  0.22580645161290322 124\nMozambique  Namaacha    26  0.20967741935483872 124\nNA  NA  43  0.3467741935483871  124\n\n\n\nCodecd example \npmotools-runner.py count_specimen_meta --file PathWeaverHeome1_PMO.json.gz --meta_fields collection_country,collection_date | head\n\ncollection_country  collection_date specimensCount  specimensFreq   totalSpecimenCount\nBangladesh  2008    15  0.0007718828796377296   19433\nBangladesh  2009    16  0.000823341738280245    19433\nBangladesh  2012    51  0.002624401790768281    19433\nBangladesh  2015    508 0.026141100190397778    19433\nBangladesh  2016    816 0.041990428652292494    19433\nBangladesh  2017    12  0.0006175063037101837   19433\nBenin   2014    41  0.002109813204343128    19433\nBenin   2016    117 0.006020686461174291    19433\nBrazil  1980    1   5.145885864251531e-05   19433\n\n\n\nThis will simply list out all the analyses (all the tar_amp_bioinformatics_info_ids) stored within a PMO\n\nCodepmotools-runner.py list_tar_amp_bioinformatics_info_ids -h \n\nusage: pmotools-runner.py list_tar_amp_bioinformatics_info_ids\n       [-h] --file FILE [--output OUTPUT] [--overwrite]\n\noptions:\n  -h, --help       show this help message and exit\n  --file FILE      PMO file\n  --output OUTPUT  output file\n  --overwrite      If output file exists, overwrite it\n\n\nThe python code for list_tar_amp_bioinformatics_info_ids script is below\n\n\nCode\npmotools-python/scripts/extract_info_from_pmo/list_tar_amp_bioinformatics_info_ids.py\n\n#!/usr/bin/env python3\nimport os, argparse, json\nimport sys\nfrom collections import defaultdict\n\nimport pandas as pd\n\nfrom pmotools.pmo_utils.PMOExtractor import PMOExtractor\nfrom pmotools.pmo_utils.PMOReader import PMOReader\nfrom pmotools.utils.small_utils import Utils\n\n\ndef parse_args_list_tar_amp_bioinformatics_info_ids():\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--file', type=str, required=True, help='PMO file')\n    parser.add_argument('--output', type=str, default=\"STDOUT\", required=False, help='output file')\n    parser.add_argument('--overwrite', action = 'store_true', help='If output file exists, overwrite it')\n\n    return parser.parse_args()\n\ndef list_tar_amp_bioinformatics_info_ids():\n    args = parse_args_list_tar_amp_bioinformatics_info_ids()\n\n    # check files\n    Utils.inputOutputFileCheck(args.file, args.output, args.overwrite)\n\n    # read in PMO\n    pmo = PMOReader.read_in_pmo(args.file)\n\n    # extract all taramp_bioinformatics_ids\n    bioids = pmo[\"taramp_bioinformatics_infos\"].keys()\n\n    # write\n    if \"STDOUT\" == args.output:\n        sys.stdout.write(\"\\n\".join(bioids) + \"\\n\")\n    else:\n        with open(args.output, \"w\") as f:\n            f.write(\"\\n\".join(bioids) + \"\\n\")\n\n\n\n\nif __name__ == \"__main__\":\n    list_tar_amp_bioinformatics_info_ids()\n\n\n\n\nCodecd example \npmotools-runner.py list_tar_amp_bioinformatics_info_ids --file moz2018_PMO.json.gz  \n\nMozambique2018-SeekDeep\n\n\n\nCodecd example \npmotools-runner.py list_tar_amp_bioinformatics_info_ids --file PathWeaverHeome1_PMO.json.gz \n\nPathWeaverHeome1\n\n\nThis can be helpful after combining PMOs\n\nCodecd example \n\npmotools-runner.py combine_pmos --pmo_files moz2018_PMO.json.gz,PathWeaverHeome1_PMO.json.gz --output combined_Heome1_PMO.json.gz --overwrite\n\npmotools-runner.py list_tar_amp_bioinformatics_info_ids --file combined_Heome1_PMO.json.gz \n\n\n\n\nMozambique2018-SeekDeep\nPathWeaverHeome1\n\n\n\nCount up the number targets each experimental_sample_id has. A read filter can be applied to see how targets would be kept if such a filter was applied\n\nCodepmotools-runner.py count_targets_per_sample -h \n\nusage: pmotools-runner.py count_targets_per_sample [-h] --file FILE\n                                                   [--output OUTPUT]\n                                                   [--delim DELIM]\n                                                   [--overwrite]\n                                                   [--read_count_minimum READ_COUNT_MINIMUM]\n\noptions:\n  -h, --help            show this help message and exit\n  --file FILE           PMO file\n  --output OUTPUT       output file\n  --delim DELIM         the delimiter of the output text file, examples input\n                        tab,comma but can also be the actual delimiter\n  --overwrite           If output file exists, overwrite it\n  --read_count_minimum READ_COUNT_MINIMUM\n                        the minimum read count (inclusive) to be counted as\n                        covered by sample\n\n\nThe python code for count_targets_per_sample script is below\n\n\nCode\npmotools-python/scripts/extract_info_from_pmo/count_targets_per_sample.py\n\n#!/usr/bin/env python3\nimport os, argparse, json\nimport sys\nfrom collections import defaultdict\n\nimport pandas as pd\n\nfrom pmotools.pmo_utils.PMOExtractor import PMOExtractor\nfrom pmotools.pmo_utils.PMOReader import PMOReader\nfrom pmotools.utils.small_utils import Utils\n\n\ndef parse_args_count_targets_per_sample():\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--file', type=str, required=True, help='PMO file')\n    parser.add_argument('--output', type=str, default=\"STDOUT\", required=False, help='output file')\n    parser.add_argument('--delim', default=\"tab\", type=str, required=False, help='the delimiter of the output text file, examples input tab,comma but can also be the actual delimiter')\n    parser.add_argument('--overwrite', action='store_true', help='If output file exists, overwrite it')\n    parser.add_argument('--read_count_minimum', default=0.0, type=float, required=False, help='the minimum read count (inclusive) to be counted as covered by sample')\n\n    return parser.parse_args()\n\n\ndef count_targets_per_sample():\n    args = parse_args_count_targets_per_sample()\n\n    # check files\n    output_delim, output_extension = Utils.process_delimiter_and_output_extension(args.delim, gzip=args.output.endswith(\".gz\"))\n    args.output = args.output if \"STDOUT\" == args.output else Utils.appendStrAsNeeded(args.output, output_extension)\n    Utils.inputOutputFileCheck(args.file, args.output, args.overwrite)\n\n    # read in PMO\n    pmo = PMOReader.read_in_pmo(args.file)\n\n    # count\n    counts_df = PMOExtractor.count_targets_per_sample(pmo, args.read_count_minimum)\n\n    #write out\n    counts_df.to_csv(sys.stdout if \"STDOUT\" == args.output else args.output, sep = output_delim, index=False)\n\n\nif __name__ == \"__main__\":\n    count_targets_per_sample()\n\n\n\n\nCodecd example \n\npmotools-runner.py count_targets_per_sample --file moz2018_PMO.json.gz  | head\n\ntar_amp_bioinformatics_info_id  experiment_sample_id    target_number\nMozambique2018-SeekDeep 8025874217  99\nMozambique2018-SeekDeep 8025874231  99\nMozambique2018-SeekDeep 8025874234  97\nMozambique2018-SeekDeep 8025874237  99\nMozambique2018-SeekDeep 8025874250  98\nMozambique2018-SeekDeep 8025874253  99\nMozambique2018-SeekDeep 8025874261  99\nMozambique2018-SeekDeep 8025874266  85\nMozambique2018-SeekDeep 8025874271  99\n\n\nApply a read count minimum filter (this a total read count summed for a target and not on a haplotype level)\n\nCodecd example \n\npmotools-runner.py count_targets_per_sample --read_count_minimum 3000 --file moz2018_PMO.json.gz  | head\n\ntar_amp_bioinformatics_info_id  experiment_sample_id    target_number\nMozambique2018-SeekDeep 8025874217  99\nMozambique2018-SeekDeep 8025874231  73\nMozambique2018-SeekDeep 8025874234  93\nMozambique2018-SeekDeep 8025874237  98\nMozambique2018-SeekDeep 8025874250  68\nMozambique2018-SeekDeep 8025874253  99\nMozambique2018-SeekDeep 8025874261  98\nMozambique2018-SeekDeep 8025874266  37\nMozambique2018-SeekDeep 8025874271  98\n\n\n\nCount up the number of experimental_sample_ids each target has. A read filter can be applied to see how many samples a taget would have if a filter was applied\n\nCodepmotools-runner.py count_samples_per_target -h \n\nusage: pmotools-runner.py count_samples_per_target [-h] --file FILE\n                                                   [--output OUTPUT]\n                                                   [--delim DELIM]\n                                                   [--overwrite]\n                                                   [--read_count_minimum READ_COUNT_MINIMUM]\n\noptions:\n  -h, --help            show this help message and exit\n  --file FILE           PMO file\n  --output OUTPUT       output file\n  --delim DELIM         the delimiter of the output text file, examples input\n                        tab,comma but can also be the actual delimiter\n  --overwrite           If output file exists, overwrite it\n  --read_count_minimum READ_COUNT_MINIMUM\n                        the minimum read count (inclusive) to be counted as\n                        covered by sample\n\n\nThe python code for count_samples_per_target script is below\n\n\nCode\npmotools-python/scripts/extract_info_from_pmo/count_samples_per_target.py\n\n#!/usr/bin/env python3\nimport os, argparse, json\nimport sys\nfrom collections import defaultdict\n\nimport pandas as pd\n\nfrom pmotools.pmo_utils.PMOExtractor import PMOExtractor\nfrom pmotools.pmo_utils.PMOReader import PMOReader\nfrom pmotools.utils.small_utils import Utils\n\n\ndef parse_args_count_samples_per_target():\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--file', type=str, required=True, help='PMO file')\n    parser.add_argument('--output', type=str, default=\"STDOUT\", required=False, help='output file')\n    parser.add_argument('--delim', default=\"tab\", type=str, required=False, help='the delimiter of the output text file, examples input tab,comma but can also be the actual delimiter')\n    parser.add_argument('--overwrite', action='store_true', help='If output file exists, overwrite it')\n    parser.add_argument('--read_count_minimum', default=0.0, type=float, required=False, help='the minimum read count (inclusive) to be counted as covered by sample')\n\n    return parser.parse_args()\n\n\ndef count_samples_per_target():\n    args = parse_args_count_samples_per_target()\n\n    # check files\n    output_delim, output_extension = Utils.process_delimiter_and_output_extension(args.delim, gzip=args.output.endswith(\".gz\"))\n    args.output = args.output if \"STDOUT\" == args.output else Utils.appendStrAsNeeded(args.output, output_extension)\n    Utils.inputOutputFileCheck(args.file, args.output, args.overwrite)\n\n    # read in PMO\n    pmo = PMOReader.read_in_pmo(args.file)\n\n    # count\n    counts_df = PMOExtractor.count_samples_per_target(pmo, args.read_count_minimum)\n\n    #write out\n    counts_df.to_csv(sys.stdout if \"STDOUT\" == args.output else args.output, sep = output_delim, index=False)\n\n\nif __name__ == \"__main__\":\n    count_samples_per_target()\n\n\n\n\nCodecd example \n\npmotools-runner.py count_samples_per_target --file moz2018_PMO.json.gz  | head\n\ntar_amp_bioinformatics_info_id  target_id   sample_number\nMozambique2018-SeekDeep t1  119\nMozambique2018-SeekDeep t10 117\nMozambique2018-SeekDeep t100    124\nMozambique2018-SeekDeep t11 120\nMozambique2018-SeekDeep t12 119\nMozambique2018-SeekDeep t13 124\nMozambique2018-SeekDeep t14 118\nMozambique2018-SeekDeep t15 119\nMozambique2018-SeekDeep t16 121\n\n\nApply a read count minimum filter (this a total read count summed for a target and not on a haplotype level)\n\nCodecd example \n\npmotools-runner.py count_samples_per_target --read_count_minimum 3000 --file moz2018_PMO.json.gz  | head\n\ntar_amp_bioinformatics_info_id  target_id   sample_number\nMozambique2018-SeekDeep t1  108\nMozambique2018-SeekDeep t10 107\nMozambique2018-SeekDeep t100    107\nMozambique2018-SeekDeep t11 111\nMozambique2018-SeekDeep t12 104\nMozambique2018-SeekDeep t13 105\nMozambique2018-SeekDeep t14 110\nMozambique2018-SeekDeep t15 110\nMozambique2018-SeekDeep t16 106"
  },
  {
    "objectID": "pmotools-python-usages/getting_basic_info_from_pmo.html#list_specimen_meta_fields",
    "href": "pmotools-python-usages/getting_basic_info_from_pmo.html#list_specimen_meta_fields",
    "title": "Getting basic info out of PMO using pmotools-python",
    "section": "",
    "text": "This will list all the meta fields within the specimen_infos section of a PMO file. Since not all meta fields are always present in all specimens, this will list the count of samples each field appears in and the number of total specimens\n\nCodepmotools-runner.py list_specimen_meta_fields -h \n\nusage: pmotools-runner.py list_specimen_meta_fields [-h] --file FILE\n                                                    [--output OUTPUT]\n                                                    [--delim DELIM]\n                                                    [--overwrite]\n\noptions:\n  -h, --help       show this help message and exit\n  --file FILE      PMO file\n  --output OUTPUT  output file\n  --delim DELIM    the delimiter of the output text file, examples input\n                   tab,comma but can also be the actual delimiter\n  --overwrite      If output file exists, overwrite it\n\n\nThe python code for list_specimen_meta_fields script is below\n\n\nCode\npmotools-python/scripts/extract_info_from_pmo/list_specimen_meta_fields.py\n\n#!/usr/bin/env python3\nimport os, argparse, json\nimport sys\nfrom collections import defaultdict\n\nimport pandas as pd\n\nfrom pmotools.pmo_utils.PMOExtractor import PMOExtractor\nfrom pmotools.pmo_utils.PMOReader import PMOReader\nfrom pmotools.utils.small_utils import Utils\n\n\ndef parse_args_list_specimen_meta_fields():\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--file', type=str, required=True, help='PMO file')\n    parser.add_argument('--output', type=str, default=\"STDOUT\", required=False, help='output file')\n    parser.add_argument('--delim', default=\"tab\", type=str, required=False, help='the delimiter of the output text file, examples input tab,comma but can also be the actual delimiter')\n    parser.add_argument('--overwrite', action = 'store_true', help='If output file exists, overwrite it')\n\n    return parser.parse_args()\n\ndef list_specimen_meta_fields():\n    args = parse_args_list_specimen_meta_fields()\n\n    # check files\n    output_delim, output_extension = Utils.process_delimiter_and_output_extension(args.delim, gzip=args.output.endswith(\".gz\"))\n    args.output = args.output if \"STDOUT\" == args.output else Utils.appendStrAsNeeded(args.output, output_extension)\n    Utils.inputOutputFileCheck(args.file, args.output, args.overwrite)\n\n    # read in PMO\n    pmo = PMOReader.read_in_pmo(args.file)\n\n    # count fields\n    counts_df = PMOExtractor.count_specimen_meta_fields(pmo)\n\n    # output\n    counts_df.to_csv(sys.stdout if \"STDOUT\" == args.output else args.output, sep = output_delim, index=False)\n\nif __name__ == \"__main__\":\n    list_specimen_meta_fields()\n\n\n\n\nCodecd example \npmotools-runner.py list_specimen_meta_fields --file moz2018_PMO.json.gz\n\nfield   presentInSpecimensCount totalSpecimenCount\ncollection_country  124 124\ncollection_date 124 124\ncollector   124 124\ngeo_admin3  124 124\nhost_taxon_id   124 124\nlat_lon 124 124\nparasite_density    124 124\nplate_col   81  124\nplate_name  81  124\nplate_row   81  124\nproject_name    124 124\nsamp_collect_device 124 124\nsamp_store_loc  124 124\nsamp_taxon_id   124 124\nspecimen_id 124 124\n\n\n\nCodecd example \npmotools-runner.py list_specimen_meta_fields --file moz2018_PMO.json.gz --output spec_fields_moz2018_PMO.tsv --overwrite"
  },
  {
    "objectID": "pmotools-python-usages/getting_basic_info_from_pmo.html#count_specimen_meta",
    "href": "pmotools-python-usages/getting_basic_info_from_pmo.html#count_specimen_meta",
    "title": "Getting basic info out of PMO using pmotools-python",
    "section": "",
    "text": "This will list all the meta values (and the combinations) for the meta fields within the specimen_infos section of a PMO file.\n\nCodepmotools-runner.py count_specimen_meta -h \n\nusage: pmotools-runner.py count_specimen_meta [-h] --file FILE\n                                              [--output OUTPUT]\n                                              [--delim DELIM] [--overwrite]\n                                              --meta_fields META_FIELDS\n\noptions:\n  -h, --help            show this help message and exit\n  --file FILE           PMO file\n  --output OUTPUT       output file\n  --delim DELIM         the delimiter of the output text file, examples input\n                        tab,comma but can also be the actual delimiter\n  --overwrite           If output file exists, overwrite it\n  --meta_fields META_FIELDS\n                        the fields to count the subfields of, can supply\n                        multiple separated by commas, e.g. --meta_fields\n                        collection_country,collection_date\n\n\nThe python code for count_specimen_meta script is below\n\n\nCode\npmotools-python/scripts/extract_info_from_pmo/count_specimen_meta.py\n\n#!/usr/bin/env python3\nimport os, argparse, json\nimport sys\nfrom collections import defaultdict\n\nimport pandas as pd\n\nfrom pmotools.pmo_utils.PMOExtractor import PMOExtractor\nfrom pmotools.pmo_utils.PMOReader import PMOReader\nfrom pmotools.utils.small_utils import Utils\n\n\ndef parse_args_count_specimen_meta():\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--file', type=str, required=True, help='PMO file')\n    parser.add_argument('--output', type=str, default=\"STDOUT\", required=False, help='output file')\n    parser.add_argument('--delim', default=\"tab\", type=str, required=False, help='the delimiter of the output text file, examples input tab,comma but can also be the actual delimiter')\n    parser.add_argument('--overwrite', action='store_true', help='If output file exists, overwrite it')\n    parser.add_argument('--meta_fields', type=str, required=True, help='the fields to count the subfields of, can supply multiple separated by commas, e.g. --meta_fields collection_country,collection_date')\n\n    return parser.parse_args()\n\n\ndef count_specimen_meta():\n    args = parse_args_count_specimen_meta()\n\n    # check files\n    output_delim, output_extension = Utils.process_delimiter_and_output_extension(args.delim, gzip=args.output.endswith(\".gz\"))\n    args.output = args.output if \"STDOUT\" == args.output else Utils.appendStrAsNeeded(args.output, output_extension)\n    Utils.inputOutputFileCheck(args.file, args.output, args.overwrite)\n\n    # process the meta_fields argument\n    meta_fields_toks = args.meta_fields.split(',')\n\n    # read in PMO\n    pmo = PMOReader.read_in_pmo(args.file)\n\n    # count sub-fields\n    counts_df = PMOExtractor.count_specimen_meta_subfields(pmo, meta_fields_toks)\n\n    #write out\n    counts_df.to_csv(sys.stdout if \"STDOUT\" == args.output else args.output, sep = output_delim, index=False)\n\n\nif __name__ == \"__main__\":\n    count_specimen_meta()\n\n\n\n\nCodecd example \npmotools-runner.py count_specimen_meta --file moz2018_PMO.json.gz --meta_fields collection_country\n\ncollection_country  specimensCount  specimensFreq   totalSpecimenCount\nMozambique  81  0.6532258064516129  124\nNA  43  0.3467741935483871  124\n\n\n\nCodecd example \npmotools-runner.py count_specimen_meta --file moz2018_PMO.json.gz --meta_fields collection_country --overwrite --output collection_country_count_moz2018_PMO.tsv.gz \n\n\n\nCodecd example \npmotools-runner.py count_specimen_meta --file moz2018_PMO.json.gz --meta_fields collection_country,geo_admin3\n\ncollection_country  geo_admin3  specimensCount  specimensFreq   totalSpecimenCount\nMozambique  Inhassoro   27  0.21774193548387097 124\nMozambique  Mandlakazi  28  0.22580645161290322 124\nMozambique  Namaacha    26  0.20967741935483872 124\nNA  NA  43  0.3467741935483871  124\n\n\n\nCodecd example \npmotools-runner.py count_specimen_meta --file PathWeaverHeome1_PMO.json.gz --meta_fields collection_country,collection_date | head\n\ncollection_country  collection_date specimensCount  specimensFreq   totalSpecimenCount\nBangladesh  2008    15  0.0007718828796377296   19433\nBangladesh  2009    16  0.000823341738280245    19433\nBangladesh  2012    51  0.002624401790768281    19433\nBangladesh  2015    508 0.026141100190397778    19433\nBangladesh  2016    816 0.041990428652292494    19433\nBangladesh  2017    12  0.0006175063037101837   19433\nBenin   2014    41  0.002109813204343128    19433\nBenin   2016    117 0.006020686461174291    19433\nBrazil  1980    1   5.145885864251531e-05   19433"
  },
  {
    "objectID": "pmotools-python-usages/getting_basic_info_from_pmo.html#list_tar_amp_bioinformatics_info_ids",
    "href": "pmotools-python-usages/getting_basic_info_from_pmo.html#list_tar_amp_bioinformatics_info_ids",
    "title": "Getting basic info out of PMO using pmotools-python",
    "section": "",
    "text": "This will simply list out all the analyses (all the tar_amp_bioinformatics_info_ids) stored within a PMO\n\nCodepmotools-runner.py list_tar_amp_bioinformatics_info_ids -h \n\nusage: pmotools-runner.py list_tar_amp_bioinformatics_info_ids\n       [-h] --file FILE [--output OUTPUT] [--overwrite]\n\noptions:\n  -h, --help       show this help message and exit\n  --file FILE      PMO file\n  --output OUTPUT  output file\n  --overwrite      If output file exists, overwrite it\n\n\nThe python code for list_tar_amp_bioinformatics_info_ids script is below\n\n\nCode\npmotools-python/scripts/extract_info_from_pmo/list_tar_amp_bioinformatics_info_ids.py\n\n#!/usr/bin/env python3\nimport os, argparse, json\nimport sys\nfrom collections import defaultdict\n\nimport pandas as pd\n\nfrom pmotools.pmo_utils.PMOExtractor import PMOExtractor\nfrom pmotools.pmo_utils.PMOReader import PMOReader\nfrom pmotools.utils.small_utils import Utils\n\n\ndef parse_args_list_tar_amp_bioinformatics_info_ids():\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--file', type=str, required=True, help='PMO file')\n    parser.add_argument('--output', type=str, default=\"STDOUT\", required=False, help='output file')\n    parser.add_argument('--overwrite', action = 'store_true', help='If output file exists, overwrite it')\n\n    return parser.parse_args()\n\ndef list_tar_amp_bioinformatics_info_ids():\n    args = parse_args_list_tar_amp_bioinformatics_info_ids()\n\n    # check files\n    Utils.inputOutputFileCheck(args.file, args.output, args.overwrite)\n\n    # read in PMO\n    pmo = PMOReader.read_in_pmo(args.file)\n\n    # extract all taramp_bioinformatics_ids\n    bioids = pmo[\"taramp_bioinformatics_infos\"].keys()\n\n    # write\n    if \"STDOUT\" == args.output:\n        sys.stdout.write(\"\\n\".join(bioids) + \"\\n\")\n    else:\n        with open(args.output, \"w\") as f:\n            f.write(\"\\n\".join(bioids) + \"\\n\")\n\n\n\n\nif __name__ == \"__main__\":\n    list_tar_amp_bioinformatics_info_ids()\n\n\n\n\nCodecd example \npmotools-runner.py list_tar_amp_bioinformatics_info_ids --file moz2018_PMO.json.gz  \n\nMozambique2018-SeekDeep\n\n\n\nCodecd example \npmotools-runner.py list_tar_amp_bioinformatics_info_ids --file PathWeaverHeome1_PMO.json.gz \n\nPathWeaverHeome1\n\n\nThis can be helpful after combining PMOs\n\nCodecd example \n\npmotools-runner.py combine_pmos --pmo_files moz2018_PMO.json.gz,PathWeaverHeome1_PMO.json.gz --output combined_Heome1_PMO.json.gz --overwrite\n\npmotools-runner.py list_tar_amp_bioinformatics_info_ids --file combined_Heome1_PMO.json.gz \n\n\n\n\nMozambique2018-SeekDeep\nPathWeaverHeome1"
  },
  {
    "objectID": "pmotools-python-usages/getting_basic_info_from_pmo.html#count_targets_per_sample",
    "href": "pmotools-python-usages/getting_basic_info_from_pmo.html#count_targets_per_sample",
    "title": "Getting basic info out of PMO using pmotools-python",
    "section": "",
    "text": "Count up the number targets each experimental_sample_id has. A read filter can be applied to see how targets would be kept if such a filter was applied\n\nCodepmotools-runner.py count_targets_per_sample -h \n\nusage: pmotools-runner.py count_targets_per_sample [-h] --file FILE\n                                                   [--output OUTPUT]\n                                                   [--delim DELIM]\n                                                   [--overwrite]\n                                                   [--read_count_minimum READ_COUNT_MINIMUM]\n\noptions:\n  -h, --help            show this help message and exit\n  --file FILE           PMO file\n  --output OUTPUT       output file\n  --delim DELIM         the delimiter of the output text file, examples input\n                        tab,comma but can also be the actual delimiter\n  --overwrite           If output file exists, overwrite it\n  --read_count_minimum READ_COUNT_MINIMUM\n                        the minimum read count (inclusive) to be counted as\n                        covered by sample\n\n\nThe python code for count_targets_per_sample script is below\n\n\nCode\npmotools-python/scripts/extract_info_from_pmo/count_targets_per_sample.py\n\n#!/usr/bin/env python3\nimport os, argparse, json\nimport sys\nfrom collections import defaultdict\n\nimport pandas as pd\n\nfrom pmotools.pmo_utils.PMOExtractor import PMOExtractor\nfrom pmotools.pmo_utils.PMOReader import PMOReader\nfrom pmotools.utils.small_utils import Utils\n\n\ndef parse_args_count_targets_per_sample():\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--file', type=str, required=True, help='PMO file')\n    parser.add_argument('--output', type=str, default=\"STDOUT\", required=False, help='output file')\n    parser.add_argument('--delim', default=\"tab\", type=str, required=False, help='the delimiter of the output text file, examples input tab,comma but can also be the actual delimiter')\n    parser.add_argument('--overwrite', action='store_true', help='If output file exists, overwrite it')\n    parser.add_argument('--read_count_minimum', default=0.0, type=float, required=False, help='the minimum read count (inclusive) to be counted as covered by sample')\n\n    return parser.parse_args()\n\n\ndef count_targets_per_sample():\n    args = parse_args_count_targets_per_sample()\n\n    # check files\n    output_delim, output_extension = Utils.process_delimiter_and_output_extension(args.delim, gzip=args.output.endswith(\".gz\"))\n    args.output = args.output if \"STDOUT\" == args.output else Utils.appendStrAsNeeded(args.output, output_extension)\n    Utils.inputOutputFileCheck(args.file, args.output, args.overwrite)\n\n    # read in PMO\n    pmo = PMOReader.read_in_pmo(args.file)\n\n    # count\n    counts_df = PMOExtractor.count_targets_per_sample(pmo, args.read_count_minimum)\n\n    #write out\n    counts_df.to_csv(sys.stdout if \"STDOUT\" == args.output else args.output, sep = output_delim, index=False)\n\n\nif __name__ == \"__main__\":\n    count_targets_per_sample()\n\n\n\n\nCodecd example \n\npmotools-runner.py count_targets_per_sample --file moz2018_PMO.json.gz  | head\n\ntar_amp_bioinformatics_info_id  experiment_sample_id    target_number\nMozambique2018-SeekDeep 8025874217  99\nMozambique2018-SeekDeep 8025874231  99\nMozambique2018-SeekDeep 8025874234  97\nMozambique2018-SeekDeep 8025874237  99\nMozambique2018-SeekDeep 8025874250  98\nMozambique2018-SeekDeep 8025874253  99\nMozambique2018-SeekDeep 8025874261  99\nMozambique2018-SeekDeep 8025874266  85\nMozambique2018-SeekDeep 8025874271  99\n\n\nApply a read count minimum filter (this a total read count summed for a target and not on a haplotype level)\n\nCodecd example \n\npmotools-runner.py count_targets_per_sample --read_count_minimum 3000 --file moz2018_PMO.json.gz  | head\n\ntar_amp_bioinformatics_info_id  experiment_sample_id    target_number\nMozambique2018-SeekDeep 8025874217  99\nMozambique2018-SeekDeep 8025874231  73\nMozambique2018-SeekDeep 8025874234  93\nMozambique2018-SeekDeep 8025874237  98\nMozambique2018-SeekDeep 8025874250  68\nMozambique2018-SeekDeep 8025874253  99\nMozambique2018-SeekDeep 8025874261  98\nMozambique2018-SeekDeep 8025874266  37\nMozambique2018-SeekDeep 8025874271  98"
  },
  {
    "objectID": "pmotools-python-usages/getting_basic_info_from_pmo.html#count_samples_per_target",
    "href": "pmotools-python-usages/getting_basic_info_from_pmo.html#count_samples_per_target",
    "title": "Getting basic info out of PMO using pmotools-python",
    "section": "",
    "text": "Count up the number of experimental_sample_ids each target has. A read filter can be applied to see how many samples a taget would have if a filter was applied\n\nCodepmotools-runner.py count_samples_per_target -h \n\nusage: pmotools-runner.py count_samples_per_target [-h] --file FILE\n                                                   [--output OUTPUT]\n                                                   [--delim DELIM]\n                                                   [--overwrite]\n                                                   [--read_count_minimum READ_COUNT_MINIMUM]\n\noptions:\n  -h, --help            show this help message and exit\n  --file FILE           PMO file\n  --output OUTPUT       output file\n  --delim DELIM         the delimiter of the output text file, examples input\n                        tab,comma but can also be the actual delimiter\n  --overwrite           If output file exists, overwrite it\n  --read_count_minimum READ_COUNT_MINIMUM\n                        the minimum read count (inclusive) to be counted as\n                        covered by sample\n\n\nThe python code for count_samples_per_target script is below\n\n\nCode\npmotools-python/scripts/extract_info_from_pmo/count_samples_per_target.py\n\n#!/usr/bin/env python3\nimport os, argparse, json\nimport sys\nfrom collections import defaultdict\n\nimport pandas as pd\n\nfrom pmotools.pmo_utils.PMOExtractor import PMOExtractor\nfrom pmotools.pmo_utils.PMOReader import PMOReader\nfrom pmotools.utils.small_utils import Utils\n\n\ndef parse_args_count_samples_per_target():\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--file', type=str, required=True, help='PMO file')\n    parser.add_argument('--output', type=str, default=\"STDOUT\", required=False, help='output file')\n    parser.add_argument('--delim', default=\"tab\", type=str, required=False, help='the delimiter of the output text file, examples input tab,comma but can also be the actual delimiter')\n    parser.add_argument('--overwrite', action='store_true', help='If output file exists, overwrite it')\n    parser.add_argument('--read_count_minimum', default=0.0, type=float, required=False, help='the minimum read count (inclusive) to be counted as covered by sample')\n\n    return parser.parse_args()\n\n\ndef count_samples_per_target():\n    args = parse_args_count_samples_per_target()\n\n    # check files\n    output_delim, output_extension = Utils.process_delimiter_and_output_extension(args.delim, gzip=args.output.endswith(\".gz\"))\n    args.output = args.output if \"STDOUT\" == args.output else Utils.appendStrAsNeeded(args.output, output_extension)\n    Utils.inputOutputFileCheck(args.file, args.output, args.overwrite)\n\n    # read in PMO\n    pmo = PMOReader.read_in_pmo(args.file)\n\n    # count\n    counts_df = PMOExtractor.count_samples_per_target(pmo, args.read_count_minimum)\n\n    #write out\n    counts_df.to_csv(sys.stdout if \"STDOUT\" == args.output else args.output, sep = output_delim, index=False)\n\n\nif __name__ == \"__main__\":\n    count_samples_per_target()\n\n\n\n\nCodecd example \n\npmotools-runner.py count_samples_per_target --file moz2018_PMO.json.gz  | head\n\ntar_amp_bioinformatics_info_id  target_id   sample_number\nMozambique2018-SeekDeep t1  119\nMozambique2018-SeekDeep t10 117\nMozambique2018-SeekDeep t100    124\nMozambique2018-SeekDeep t11 120\nMozambique2018-SeekDeep t12 119\nMozambique2018-SeekDeep t13 124\nMozambique2018-SeekDeep t14 118\nMozambique2018-SeekDeep t15 119\nMozambique2018-SeekDeep t16 121\n\n\nApply a read count minimum filter (this a total read count summed for a target and not on a haplotype level)\n\nCodecd example \n\npmotools-runner.py count_samples_per_target --read_count_minimum 3000 --file moz2018_PMO.json.gz  | head\n\ntar_amp_bioinformatics_info_id  target_id   sample_number\nMozambique2018-SeekDeep t1  108\nMozambique2018-SeekDeep t10 107\nMozambique2018-SeekDeep t100    107\nMozambique2018-SeekDeep t11 111\nMozambique2018-SeekDeep t12 104\nMozambique2018-SeekDeep t13 105\nMozambique2018-SeekDeep t14 110\nMozambique2018-SeekDeep t15 110\nMozambique2018-SeekDeep t16 106"
  },
  {
    "objectID": "format/FormatOverview.html",
    "href": "format/FormatOverview.html",
    "title": "PMO fields overview",
    "section": "",
    "text": "Creating fields with efforts to be consistent with MIxS standards\nImportant aspects to keep in mind are creating an efficient, low-weight, and minimum amount of information about a run without losing any important data. We can build tools around this table to generate certain fields that are important but not necessary always to keep constantly stored in this base class (e.g. SNP/INDEL calls). Also since we are proposing to keep this data in a singular file in JSON format we are not limited to keeping data in a tabular format for organization; output generated from this file can certainly be a table but we don’t have to store things as a table, e.g. certain fields might be a single ID while other fields might be vectors/lists of data. What’s most important is that we agree on what fields are important and what they should store (and what values should be allowable or formatting, e.g. double/floats vs strings vs characters vs POSIX date vs URL etc)\nFormat is defined by utilizing LinkML to generate a general data scheme which creates convenient outputs like JSON Schema for validation tools.\nOther notable users of LinkML/MIxS National Microbiome Data Collaborative Schema"
  },
  {
    "objectID": "format/FormatOverview.html#portablemicrohaplotypeobject",
    "href": "format/FormatOverview.html#portablemicrohaplotypeobject",
    "title": "PMO fields overview",
    "section": "PortableMicrohaplotypeObject",
    "text": "PortableMicrohaplotypeObject\nhttps://plasmogenepi.github.io/portable-microhaplotype-object/PortableMicrohaplotypeObject/\nRequired\n\npmo_name (type=string)\n\na name for this PMO, can be a concatenation of names if combined more than one PMO\n\n\n\nexperiment_infos (type=ExperimentInfo)\n\na list of experiments of all the seq/amp of samples within this project\n\n\n\nspecimen_infos (type=SpecimenInfo)\n\na list of SpecimenInfo of all the samples within this project\n\n\n\nsequencing_infos (type=SequencingInfo)\n\nthe sequencing info for this project\n\n\n\npanel_info (type=PanelInfo)\n\nthe info on the targeted sequencing panel used for this project\n\n\n\nrepresentative_microhaplotype_sequences (type=RepresentativeMicrohaplotypeSequences)\n\na list of the representative sequences for the results for this project\n\n\n\nmicrohaplotypes_detected (type=MicrohaplotypesDetected)\n\nthe microhaplotypes detected in this projects\n\n\n\ntaramp_bioinformatics_infos (type=TarAmpBioinformaticsInfo)\n\nthe bioinformatics pipeline/methods used to generated the amplicon analysis for this project\n\n\nOptional\n\npostprocessing_bioinformatics_infos (type=BioMethod)\n\nany additional methods that were applied to the processing of this file/analysis, this can be filtering, adding info etc\n\n\n\ntarget_demultiplexed_experiment_samples (type=DemultiplexedExperimentSamples)\n\nthe raw demultiplex target counts for each sample"
  },
  {
    "objectID": "format/FormatOverview.html#tarampbioinformaticsinfo",
    "href": "format/FormatOverview.html#tarampbioinformaticsinfo",
    "title": "PMO fields overview",
    "section": "TarAmpBioinformaticsInfo",
    "text": "TarAmpBioinformaticsInfo\nhttps://plasmogenepi.github.io/portable-microhaplotype-object/TarAmpBioinformaticsInfo/\nRequired\n\ntar_amp_bioinformatics_info_id (type=string)\n\na unique identifier for this targeted amplicon bioinformatics pipeline run\n\n\n\ndemultiplexing_method (type=BioMethod)\n\nthe demultiplexing method used to separate raw reads from barcodes and primer targets\n\n\n\ndenoising_method (type=BioMethod)\n\nthe method used to de-noise and/or cluster the raw reads\n\n\n\npopulation_clustering_method (type=BioMethod)\n\nthe method used to compare clustered/de-noised reads across samples for a target\n\n\nOptional\n\nadditional_methods (type=BioMethod)\n\nany additional methods used to analyze the data\n\n\nExample\n\nCode        {\n            \"demultiplexing_method\" : \n            {\n                \"program\" : \"SeekDeep extractorPairedEnd\",\n                \"purpose\" : \"Takes raw paired-end reads and demultiplexes on primers and does QC filtering\",\n                \"version\" : \"v2.6.5\"\n            },\n            \"denoising_method\" : \n            {\n                \"additional_argument\" : \"--illumina --qualThres 25,20 --trimFront 1 --trimBack 1\",\n                \"program\" : \"SeekDeep qluster\",\n                \"purpose\" : \"Takes sequences per sample per target and clusters them\",\n                \"version\" : \"v2.6.5\"\n            },\n            \"population_clustering_method\" : \n            {\n                \"additional_argument\" : \"--strictErrors  --illumina --removeOneSampOnlyOneOffHaps --excludeCommonlyLowFreqHaplotypes --excludeLowFreqOneOffs --rescueExcludedOneOffLowFreqHaplotypes\",\n                \"program\" : \"SeekDeep processClusters\",\n                \"purpose\" : \"Compare across samples for each target to create population level identifiers and do post artifact cleanup\",\n                \"version\" : \"v2.6.5\"\n            },\n            \"tar_amp_bioinformatics_info_id\" : \"Mozambique2018-SeekDeep\"\n        }"
  },
  {
    "objectID": "format/FormatOverview.html#biomethod",
    "href": "format/FormatOverview.html#biomethod",
    "title": "PMO fields overview",
    "section": "BioMethod",
    "text": "BioMethod\nhttps://plasmogenepi.github.io/portable-microhaplotype-object/BioMethod/\nRequired\n\nprogram (type=string)\n\nname of the program used for this portion of the pipeline\n\n\n\npurpose (type=string)\n\nthe purpose for this method\n\n\n\nprogram_version (type=string)\n\nversioning info for the program\n\n\nOptional\n\nadditional_argument (type=array)\n\nany additional arguments that differ from the default\n\n\nExample\n\nCode            {\n                \"additional_argument\" : \"--strictErrors  --illumina --removeOneSampOnlyOneOffHaps --excludeCommonlyLowFreqHaplotypes --excludeLowFreqOneOffs --rescueExcludedOneOffLowFreqHaplotypes\",\n                \"program\" : \"SeekDeep processClusters\",\n                \"purpose\" : \"Compare across samples for each target to create population level identifiers and do post artifact cleanup\",\n                \"version\" : \"v2.6.5\"\n            },"
  },
  {
    "objectID": "format/FormatOverview.html#demultiplexedexperimentsamples",
    "href": "format/FormatOverview.html#demultiplexedexperimentsamples",
    "title": "PMO fields overview",
    "section": "DemultiplexedExperimentSamples",
    "text": "DemultiplexedExperimentSamples\nhttps://plasmogenepi.github.io/portable-microhaplotype-object/DemultiplexedExperimentSamples/\nRequired\n\ntar_amp_bioinformatics_info_id (type=string)\n\na unique identifier for this targeted amplicon bioinformatics pipeline run\n\n\n\ndemultiplexed_experiment_samples (type=DemultiplexedTargetsForExperimentSample)\n\na list of the samples with the number of raw reads extracted\n\n\nExample\n\nCode            \"tar_amp_bioinformatics_info_id\" : \"Mozambique2018-SeekDeep\", \n            \"demultiplexed_experiment_samples\" : \n            {\n                \"1112282540\" : \n                {\n                    \"demultiplexed_targets\" : \n                    {\n                        \"t1\" : \n                        {\n                            \"raw_read_count\" : 34.0,\n                            \"target_id\" : \"t1\"\n                        },\n                        \"t10\" : \n                        {\n                            \"raw_read_count\" : 205.0,\n                            \"target_id\" : \"t10\"\n                        },\n                        \"t100\" : \n                        {\n                            \"raw_read_count\" : 159.0,\n                            \"target_id\" : \"t100\"\n                        },"
  },
  {
    "objectID": "format/FormatOverview.html#demultiplexedtargetforexperimentsample",
    "href": "format/FormatOverview.html#demultiplexedtargetforexperimentsample",
    "title": "PMO fields overview",
    "section": "DemultiplexedTargetForExperimentSample",
    "text": "DemultiplexedTargetForExperimentSample\nhttps://plasmogenepi.github.io/portable-microhaplotype-object/DemultiplexedTargetForExperimentSample/\nRequired\n\ntarget_id (type=string)\n\nname of the target\n\n\n\nraw_read_count (type=number)\n\nthe raw read counts extracted for a target for a experiment sample\n\n\nExample\n\nCode                        \"t100\" : \n                        {\n                            \"raw_read_count\" : 159.0,\n                            \"target_id\" : \"t100\"\n                        },"
  },
  {
    "objectID": "format/FormatOverview.html#demultiplexedtargetsforexperimentsample",
    "href": "format/FormatOverview.html#demultiplexedtargetsforexperimentsample",
    "title": "PMO fields overview",
    "section": "DemultiplexedTargetsForExperimentSample",
    "text": "DemultiplexedTargetsForExperimentSample\nhttps://plasmogenepi.github.io/portable-microhaplotype-object/DemultiplexedTargetsForExperimentSample/\nRequired\n\nexperiment_sample_id (type=string)\n\na unique identifier for this sequence/amplification run on a specimen\n\n\n\ndemultiplexed_targets (type=DemultiplexedTargetForExperimentSample)\n\na list of the targets extracted for a sample\n\n\nExample\n\nCode                    \"demultiplexed_targets\" : \n                    {\n                        \"t1\" : \n                        {\n                            \"raw_read_count\" : 34.0,\n                            \"target_id\" : \"t1\"\n                        },\n                        \"t10\" : \n                        {\n                            \"raw_read_count\" : 205.0,\n                            \"target_id\" : \"t10\"\n                        },\n                        \"t100\" : \n                        {\n                            \"raw_read_count\" : 159.0,\n                            \"target_id\" : \"t100\"\n                        },\n                        \"t11\" : \n                        {\n                            \"raw_read_count\" : 198.0,\n                            \"target_id\" : \"t11\"\n                        },\n                        \"t12\" : \n                        {\n                            \"raw_read_count\" : 19.0,\n                            \"target_id\" : \"t12\"\n                        },\n                        \"t13\" : \n                        {\n                            \"raw_read_count\" : 66.0,\n                            \"target_id\" : \"t13\"\n                        },\n                    \"experiment_sample_id\" : \"1112282540\""
  },
  {
    "objectID": "format/FormatOverview.html#microhaplotypefortarget",
    "href": "format/FormatOverview.html#microhaplotypefortarget",
    "title": "PMO fields overview",
    "section": "MicrohaplotypeForTarget",
    "text": "MicrohaplotypeForTarget\nhttps://plasmogenepi.github.io/portable-microhaplotype-object/MicrohaplotypeForTarget/\nRequired\n\nmicrohaplotype_id (type=string)\n\nname of the microhaplotype, should be unique to this microhaplotype\n\n\n\nread_count (type=number)\n\nthe read count associated with this microhaplotype\n\n\nOptional\n\numi_count (type=number)\n\nthe unique molecular identifier (umi) count associated with this microhaplotype\n\n\nExample\n\nCode                                {\n                                    \"microhaplotype_id\" : \"t1.0\",\n                                    \"read_count\" : 11600.0\n                                }"
  },
  {
    "objectID": "format/FormatOverview.html#microhaplotypesdetected",
    "href": "format/FormatOverview.html#microhaplotypesdetected",
    "title": "PMO fields overview",
    "section": "MicrohaplotypesDetected",
    "text": "MicrohaplotypesDetected\nhttps://plasmogenepi.github.io/portable-microhaplotype-object/MicrohaplotypesDetected/\nRequired\n\ntar_amp_bioinformatics_info_id (type=string)\n\na unique identifier for this targeted amplicon bioinformatics pipeline run\n\n\n\nrepresentative_microhaplotype_id (type=string)\n\nan identifier for the representative microhaplotype object collection\n\n\n\nexperiment_samples (type=MicrohaplotypesForSample)\n\na list of the microhaplotypes detected for a sample for various targets\n\n\nExample\n\nCode            \"representative_microhaplotype_id\" : \"Mozambique2018-SeekDeep\",\n            \"tar_amp_bioinformatics_info_id\" : \"Mozambique2018-SeekDeep\", \n            \"experiment_samples\" : \n            {\n                \"8025874217\" : \n                {\n                    \"experiment_sample_id\" : \"8025874217\",\n                    \"target_results\" : \n                    {\n                        \"t1\" : \n                        {\n                            \"microhaplotypes\" : \n                            [\n                                {\n                                    \"microhaplotype_id\" : \"t1.2\",\n                                    \"read_count\" : 34463.0\n                                },\n                                {\n                                    \"microhaplotype_id\" : \"t1.0\",\n                                    \"read_count\" : 11600.0\n                                }\n                            ],\n                            \"target_id\" : \"t1\"\n                        },\n                        \"t10\" : \n                        {\n                            \"microhaplotypes\" : \n                            [\n                                {\n                                    \"microhaplotype_id\" : \"t10.0\",\n                                    \"read_count\" : 49728.0\n                                }\n                            ],\n                            \"target_id\" : \"t10\"\n                        },\n                        \"t100\" : \n                        {\n                            \"microhaplotypes\" : \n                            [\n                                {\n                                    \"microhaplotype_id\" : \"t100.05\",\n                                    \"read_count\" : 49740.0\n                                }\n                            ],\n                            \"target_id\" : \"t100\"\n                        },"
  },
  {
    "objectID": "format/FormatOverview.html#microhaplotypesforsample",
    "href": "format/FormatOverview.html#microhaplotypesforsample",
    "title": "PMO fields overview",
    "section": "MicrohaplotypesForSample",
    "text": "MicrohaplotypesForSample\nhttps://plasmogenepi.github.io/portable-microhaplotype-object/MicrohaplotypesForSample/\nRequired\n\nexperiment_sample_id (type=string)\n\na unique identifier for this sequence/amplification run on a specimen\n\n\n\ntarget_results (type=MicrohaplotypesForTarget)\n\na list of the microhaplotypes detected for a list of targets\n\n\nExample\n\nCode                {\n                    \"experiment_sample_id\" : \"8025874217\",\n                    \"target_results\" : \n                    {\n                        \"t1\" : \n                        {\n                            \"microhaplotypes\" : \n                            [\n                                {\n                                    \"microhaplotype_id\" : \"t1.2\",\n                                    \"read_count\" : 34463.0\n                                },\n                                {\n                                    \"microhaplotype_id\" : \"t1.0\",\n                                    \"read_count\" : 11600.0\n                                }\n                            ],\n                            \"target_id\" : \"t1\"\n                        },\n                        \"t10\" : \n                        {\n                            \"microhaplotypes\" : \n                            [\n                                {\n                                    \"microhaplotype_id\" : \"t10.0\",\n                                    \"read_count\" : 49728.0\n                                }\n                            ],\n                            \"target_id\" : \"t10\"\n                        },\n                        \"t100\" : \n                        {\n                            \"microhaplotypes\" : \n                            [\n                                {\n                                    \"microhaplotype_id\" : \"t100.05\",\n                                    \"read_count\" : 49740.0\n                                }\n                            ],\n                            \"target_id\" : \"t100\"\n                        },"
  },
  {
    "objectID": "format/FormatOverview.html#microhaplotypesfortarget",
    "href": "format/FormatOverview.html#microhaplotypesfortarget",
    "title": "PMO fields overview",
    "section": "MicrohaplotypesForTarget",
    "text": "MicrohaplotypesForTarget\nhttps://plasmogenepi.github.io/portable-microhaplotype-object/MicrohaplotypesForTarget/\nRequired\n\ntarget_id (type=string)\n\nname of the target\n\n\n\nmicrohaplotypes (type=MicrohaplotypeForTarget)\n\na list of the microhaplotypes detected for this target\n\n\nExample\n\nCode                        {\n                            \"microhaplotypes\" : \n                            [\n                                {\n                                    \"microhaplotype_id\" : \"t1.2\",\n                                    \"read_count\" : 34463.0\n                                },\n                                {\n                                    \"microhaplotype_id\" : \"t1.0\",\n                                    \"read_count\" : 11600.0\n                                }\n                            ],\n                            \"target_id\" : \"t1\"\n                        },"
  },
  {
    "objectID": "format/FormatOverview.html#panelinfo",
    "href": "format/FormatOverview.html#panelinfo",
    "title": "PMO fields overview",
    "section": "PanelInfo",
    "text": "PanelInfo\nhttps://plasmogenepi.github.io/portable-microhaplotype-object/PanelInfo/\nRequired\n\npanel_id (type=string)\n\nname of the panel\n\n\n\ntarget_genome (type=GenomeInfo)\n\nthe info on the target reference genome for this panel\n\n\n\npanel_targets (type=TargetInfo)\n\na list of the target infos for the targets in this panel\n\n\nExample\n\nCode    \"panel_info\" : \n    {\n        \"panel_id\" : \"heomev1\",\n        \"target_genome\" : \n        {\n            \"gff_url\" : \"https://plasmodb.org/common/downloads/release-65/Pfalciparum3D7/gff/data/PlasmoDB-65_Pfalciparum3D7.gff\",\n            \"name\" : \"3D7\",\n            \"taxon_id\" : 5833,\n            \"url\" : \"https://plasmodb.org/common/downloads/release-65/Pfalciparum3D7/fasta/data/PlasmoDB-65_Pfalciparum3D7_Genome.fasta\",\n            \"version\" : \"2020-09-01\"\n        },\n        \"targets\" : \n        {\n            \"t1\" : \n            {\n                \"forward_primers\" : \n                [\n                    {\n                        \"location\" : \n                        {\n                            \"chrom\" : \"Pf3D7_01_v3\",\n                            \"end\" : 145449,\n                            \"start\" : 145416,\n                            \"strand\" : \"+\"\n                        },\n                        \"seq\" : \"TGTTCGATATGTTTAAATATATGATTCTCGAAA\"\n                    }\n                ],\n                \"gene_id\" : \"PF3D7_0103300\",\n                \"insert_location\" : \n                {\n                    \"chrom\" : \"Pf3D7_01_v3\",\n                    \"end\" : 145622,\n                    \"start\" : 145449,\n                    \"strand\" : \"+\"\n                },\n                \"reverse_primers\" : \n                [\n                    {\n                        \"location\" : \n                        {\n                            \"chrom\" : \"Pf3D7_01_v3\",\n                            \"end\" : 145449,\n                            \"start\" : 145416,\n                            \"strand\" : \"+\"\n                        },\n                        \"seq\" : \"CCAATATGTCAAGGTATATTAAAGTATGGTATC\"\n                    }\n                ],\n                \"target_id\" : \"t1\"\n            },\n            \"t10\" : \n            {\n                \"forward_primers\" : \n                [\n                    {\n                        \"location\" : \n                        {\n                            \"chrom\" : \"Pf3D7_02_v3\",\n                            \"end\" : 109807,\n                            \"start\" : 109776,\n                            \"strand\" : \"+\"\n                        },\n                        \"seq\" : \"CCACCATTTCTTCATTTTAATTTTGAATGGT\"\n                    }\n                ],\n                \"gene_id\" : \"PF3D7_0202100\",\n                \"insert_location\" : \n                {\n                    \"chrom\" : \"Pf3D7_02_v3\",\n                    \"end\" : 109982,\n                    \"start\" : 109807,\n                    \"strand\" : \"+\"\n                },\n                \"reverse_primers\" : \n                [\n                    {\n                        \"location\" : \n                        {\n                            \"chrom\" : \"Pf3D7_02_v3\",\n                            \"end\" : 109807,\n                            \"start\" : 109776,\n                            \"strand\" : \"+\"\n                        },\n                        \"seq\" : \"ACCATTTGGATTAAAACCTTCAGATTTAAATA\"\n                    }\n                ],\n                \"target_id\" : \"t10\"\n            },"
  },
  {
    "objectID": "format/FormatOverview.html#targetinfo",
    "href": "format/FormatOverview.html#targetinfo",
    "title": "PMO fields overview",
    "section": "TargetInfo",
    "text": "TargetInfo\nhttps://plasmogenepi.github.io/portable-microhaplotype-object/TargetInfo/\nRequired\n\ntarget_id (type=string)\n\nname of the target\n\n\n\nforward_primers (type=PrimerInfo)\n\nA list of forward primers associated with this target\n\n\n\nreverse_primers (type=PrimerInfo)\n\nA list of reverse primers associated with this target\n\n\nOptional\n\ngene_id (type=string)\n\nan identifier of the gene, if any, is being covered with this targeted\n\n\n\ninsert_location (type=GenomicLocation)\n\nthe intended genomic location of the insert of the amplicon (the location between the end of the forward primer and the beginning of the reverse primer)\n\n\n\ntarget_type (type=array)\n\na list of classification type for the primer target\n\n\nExample\n\nCode            {\n                \"forward_primers\" : \n                [\n                    {\n                        \"location\" : \n                        {\n                            \"chrom\" : \"Pf3D7_01_v3\",\n                            \"end\" : 145449,\n                            \"start\" : 145416,\n                            \"strand\" : \"+\"\n                        },\n                        \"seq\" : \"TGTTCGATATGTTTAAATATATGATTCTCGAAA\"\n                    }\n                ],\n                \"gene_id\" : \"PF3D7_0103300\",\n                \"insert_location\" : \n                {\n                    \"chrom\" : \"Pf3D7_01_v3\",\n                    \"end\" : 145622,\n                    \"start\" : 145449,\n                    \"strand\" : \"+\"\n                },\n                \"reverse_primers\" : \n                [\n                    {\n                        \"location\" : \n                        {\n                            \"chrom\" : \"Pf3D7_01_v3\",\n                            \"end\" : 145449,\n                            \"start\" : 145416,\n                            \"strand\" : \"+\"\n                        },\n                        \"seq\" : \"CCAATATGTCAAGGTATATTAAAGTATGGTATC\"\n                    }\n                ],\n                \"target_id\" : \"t1\"\n            },"
  },
  {
    "objectID": "format/FormatOverview.html#primerinfo",
    "href": "format/FormatOverview.html#primerinfo",
    "title": "PMO fields overview",
    "section": "PrimerInfo",
    "text": "PrimerInfo\nhttps://plasmogenepi.github.io/portable-microhaplotype-object/PrimerInfo/\nRequired\n\nseq (type=string)\n\nthe DNA sequence\n\n\nOptional\n\nlocation (type=GenomicLocation)\n\nwhat the intended genomic location of the primer is\n\n\nExample\n\nCode                    {\n                        \"location\" : \n                        {\n                            \"chrom\" : \"Pf3D7_01_v3\",\n                            \"end\" : 145449,\n                            \"start\" : 145416,\n                            \"strand\" : \"+\"\n                        },\n                        \"seq\" : \"TGTTCGATATGTTTAAATATATGATTCTCGAAA\"\n                    }"
  },
  {
    "objectID": "format/FormatOverview.html#maskinginfo",
    "href": "format/FormatOverview.html#maskinginfo",
    "title": "PMO fields overview",
    "section": "MaskingInfo",
    "text": "MaskingInfo\nhttps://plasmogenepi.github.io/portable-microhaplotype-object/MaskingInfo/\nRequired\n\nseq_start (type=integer)\n\nthe start of the masking\n\n\n\nseq_segment_size (type=integer)\n\nthe size of the masking\n\n\n\nreplacement_size (type=integer)\n\nthe size of replacement mask\n\n\nExample\n\nCode[\n    {\n        seq_start : 10, \n        seq_segment_size : 5, \n        replacement_size : 3  \n    }, \n    {\n        seq_start : 45, \n        seq_segment_size : 7, \n        replacement_size : 7\n    }, \n]"
  },
  {
    "objectID": "format/FormatOverview.html#genomeinfo",
    "href": "format/FormatOverview.html#genomeinfo",
    "title": "PMO fields overview",
    "section": "GenomeInfo",
    "text": "GenomeInfo\nhttps://plasmogenepi.github.io/portable-microhaplotype-object/GenomeInfo/\nRequired\n\nname (type=string)\n\nname of the genome\n\n\n\nversion (type=string)\n\nthe genome version\n\n\n\ntaxon_id (type=integer)\n\nthe NCBI taxonomy number\n\n\n\nurl (type=string)\n\na link to the where this genome file could be downloaded\n\n\nOptional\n\ngff_url (type=string)\n\na link to the where this genome’s annotation file could be downloaded\n\n\nExample\n\nCode        {\n            \"gff_url\" : \"https://plasmodb.org/common/downloads/release-65/Pfalciparum3D7/gff/data/PlasmoDB-65_Pfalciparum3D7.gff\",\n            \"name\" : \"3D7\",\n            \"taxon_id\" : 5833,\n            \"url\" : \"https://plasmodb.org/common/downloads/release-65/Pfalciparum3D7/fasta/data/PlasmoDB-65_Pfalciparum3D7_Genome.fasta\",\n            \"version\" : \"2020-09-01\"\n        },"
  },
  {
    "objectID": "format/FormatOverview.html#genomiclocation",
    "href": "format/FormatOverview.html#genomiclocation",
    "title": "PMO fields overview",
    "section": "GenomicLocation",
    "text": "GenomicLocation\nhttps://plasmogenepi.github.io/portable-microhaplotype-object/GenomicLocation/\nRequired\n\nchrom (type=string)\n\nthe chromosome name\n\n\n\nstart (type=integer)\n\nthe start of the location, 0-based positioning\n\n\n\nend (type=integer)\n\nthe end of the location, 0-based positioning\n\n\nOptional\n\nref_seq (type=string)\n\nthe reference sequence of this genomic location\n\n\n\nstrand (type=string)\n\nwhich strand the location is, either + for plus strand or - for negative strand\n\n\nExample\n\nCode                        {\n                            \"chrom\" : \"Pf3D7_01_v3\",\n                            \"end\" : 145449,\n                            \"start\" : 145416,\n                            \"strand\" : \"+\"\n                        },"
  },
  {
    "objectID": "format/FormatOverview.html#representativemicrohaplotypesequences",
    "href": "format/FormatOverview.html#representativemicrohaplotypesequences",
    "title": "PMO fields overview",
    "section": "RepresentativeMicrohaplotypeSequences",
    "text": "RepresentativeMicrohaplotypeSequences\nhttps://plasmogenepi.github.io/portable-microhaplotype-object/RepresentativeMicrohaplotypeSequences/\nRequired\n\nrepresentative_microhaplotype_id (type=string)\n\nan identifier for the representative microhaplotype object collection\n\n\n\ntargets (type=RepresentativeMicrohaplotypesForTarget)\n\na list of the targets detected for this analysis\n\n\nExample\n\nCode            \"representative_microhaplotype_id\" : \"Mozambique2018-SeekDeep\",\n            \"targets\" : \n            {\n                \"t1\" : \n                {\n                    \"seqs\" : \n                    {\n                        \"t1.0\" : \n                        {\n                            \"microhaplotype_id\" : \"t1.0\",\n                            \"seq\" : \"AACTTTTTTTATTTTTTTTGTCAATAGATAAATGATCAATATTTTCTATATTTAATCTATCAAGTATTTTTATATATCTATTATTTCTTTCTTCGATGGATAAATTATAAGAATCAATATCCTTTCTTTCATCAACAAACTTTTTTATTGTTAACTCCATTTTTTTATTTA\"\n                        },\n                        \"t1.1\" : \n                        {\n                            \"microhaplotype_id\" : \"t1.1\",\n                            \"seq\" : \"AACTTTTTTTATTTTTTTTGTCAATAGATAAATGATCAATATTTTCTATATTTAATCTATCAAGAATTTTTATATATCTATTATTTCTTTCTTCGATGGATAAATTATATGAATCAATATCCTTTCTTTCATCAACAAACTTTTTTATTGTTAACTCCATTTTTTTATTTA\"\n                        },"
  },
  {
    "objectID": "format/FormatOverview.html#representativemicrohaplotypesfortarget",
    "href": "format/FormatOverview.html#representativemicrohaplotypesfortarget",
    "title": "PMO fields overview",
    "section": "RepresentativeMicrohaplotypesForTarget",
    "text": "RepresentativeMicrohaplotypesForTarget\nhttps://plasmogenepi.github.io/portable-microhaplotype-object/RepresentativeMicrohaplotypesForTarget/\nRequired\n\ntarget_id (type=string)\n\nname of the target\n\n\n\nseqs (type=RepresentativeMicrohaplotypeSequence)\n\na list of the microhaplotypes detected for a target\n\n\nExample\n\nCode                {\n                    \"seqs\" : \n                    {\n                        \"t1.0\" : \n                        {\n                            \"microhaplotype_id\" : \"t1.0\",\n                            \"seq\" : \"AACTTTTTTTATTTTTTTTGTCAATAGATAAATGATCAATATTTTCTATATTTAATCTATCAAGTATTTTTATATATCTATTATTTCTTTCTTCGATGGATAAATTATAAGAATCAATATCCTTTCTTTCATCAACAAACTTTTTTATTGTTAACTCCATTTTTTTATTTA\"\n                        },\n                        \"t1.1\" : \n                        {\n                            \"microhaplotype_id\" : \"t1.1\",\n                            \"seq\" : \"AACTTTTTTTATTTTTTTTGTCAATAGATAAATGATCAATATTTTCTATATTTAATCTATCAAGAATTTTTATATATCTATTATTTCTTTCTTCGATGGATAAATTATATGAATCAATATCCTTTCTTTCATCAACAAACTTTTTTATTGTTAACTCCATTTTTTTATTTA\"\n                        },\n                        \"t1.2\" : \n                        {\n                            \"microhaplotype_id\" : \"t1.2\",\n                            \"seq\" : \"AACTTTTTTTATTTTTTTTGTCAATAGATAAATGATCAATATTTTCTATATTTAATCTATCAAGTATTTTTATATATCTATTATTTCTTTCTTCGATGGATAAATTATATGAATCAATATCCTTTCTTTCATCAACAAACTTTTTTATTGTTAACTCCATTTTTTTATTTA\"\n                        },\n                        \"t1.3\" : \n                        {\n                            \"microhaplotype_id\" : \"t1.3\",\n                            \"seq\" : \"AACTTTTTTTATTTTTTTTGTCAATAGATAAATGATCAATATTTTCTATATTTAATCTATCAAGAATTTTTATATATCTATTATTTCTTTCTTCGATGGATAAATTATAAGAATCAATATCCTTTCTTTCATCAACAAACTTTTTTATTGTTAACTCCATTTTTTTATTTA\"\n                        },\n                        \"t1.4\" : \n                        {\n                            \"microhaplotype_id\" : \"t1.4\",\n                            \"seq\" : \"AACTTTTTTTATTTTTTTTGTCAATAGATAAATGATCAATATTTTCTATATTTAATCTATCAAGTATTTTTATATATCTATTATTTCTTTCTTCGATGGATAAATTATAAGAATCAATATCCTTTCTTTCATCAACAAACTTTTTTATGGTTAACTCCATTTTTTTATTTA\"\n                        },\n                        \"t1.5\" : \n                        {\n                            \"microhaplotype_id\" : \"t1.5\",\n                            \"seq\" : \"AACTTTTTTTATTTTTTTTGTCAATAGATAAATGATCAATATTTTCTATATTTAATCTATCAAGAATTTTTATATATCTATTATTTCTTTCTTCGAAGGATAAATTATAAGAATCAATATCCTTTCTTTCATCAACAAACTTTTTTATTGTTAACTCCATTTTTTTATTTA\"\n                        }\n                    },\n                    \"target_id\" : \"t1\"\n                },"
  },
  {
    "objectID": "format/FormatOverview.html#representativemicrohaplotypesequence",
    "href": "format/FormatOverview.html#representativemicrohaplotypesequence",
    "title": "PMO fields overview",
    "section": "RepresentativeMicrohaplotypeSequence",
    "text": "RepresentativeMicrohaplotypeSequence\nhttps://plasmogenepi.github.io/portable-microhaplotype-object/RepresentativeMicrohaplotypeSequence/\nRequired\n\nseq (type=string)\n\nthe DNA sequence\n\n\n\nmicrohaplotype_id (type=string)\n\nname of the microhaplotype, should be unique to this microhaplotype\n\n\nOptional\n\nalt_annotations (type=array)\n\na list of additional annotations associated with this microhaplotype, e.g. wildtype, amino acid changes etc\n\n\n\nmasking (type=MaskingInfo)\n\nmasking info for the sequence\n\n\n\npseudocigar (type=string)\n\nthe pseudocigar of the haplotype\n\n\n\nquality (type=string)\n\nthe ansi fastq per base quality score for this sequence, this is optional\n\n\nExample\n\nCode                        {\n                            \"microhaplotype_id\" : \"t1.0\",\n                            \"seq\" : \"AACTTTTTTTATTTTTTTTGTCAATAGATAAATGATCAATATTTTCTATATTTAATCTATCAAGTATTTTTATATATCTATTATTTCTTTCTTCGATGGATAAATTATAAGAATCAATATCCTTTCTTTCATCAACAAACTTTTTTATTGTTAACTCCATTTTTTTATTTA\"\n                        },"
  },
  {
    "objectID": "format/FormatOverview.html#sequencinginfo",
    "href": "format/FormatOverview.html#sequencinginfo",
    "title": "PMO fields overview",
    "section": "SequencingInfo",
    "text": "SequencingInfo\nhttps://plasmogenepi.github.io/portable-microhaplotype-object/SequencingInfo/\nRequired\n\nsequencing_info_id (type=string)\n\na unique identifier for this sequencing info\n\n\n\nseq_instrument (type=string)\n\nthe sequencing instrument used to sequence the run, e.g. ILLUMINA, Illumina MiSeq\n\n\n\nseq_date (type=string)\n\nthe date of sequencing, should be YYYY-MM or YYYY-MM-DD\n\n\n\nnucl_acid_ext (type=string)\n\nLink to a reference or kit that describes the recovery of nucleic acids from the sample\n\n\n\nnucl_acid_amp (type=string)\n\nLink to a reference or kit that describes the enzymatic amplification of nucleic acids,\n\n\n\nnucl_acid_ext_date (type=string)\n\nthe date of the nucleoacide extraction\n\n\n\nnucl_acid_amp_date (type=string)\n\nthe date of the nucleoacide amplification\n\n\n\npcr_cond (type=string)\n\nthe method/conditions for PCR, List PCR cycles used to amplify the target\n\n\n\nlib_screen (type=string)\n\nDescribe enrichment, screening, or normalization methods applied during amplification or library preparation, e.g. size selection 390bp, diluted to 1 ng DNA/sample\n\n\n\nlib_layout (type=string)\n\nSpecify the configuration of reads, e.g. paired-end\n\n\n\nlib_kit (type=string)\n\nName, version, and applicable cell or cycle numbers for the kit used to prepare libraries and load cells or chips for sequencing. If possible, include a part number, e.g. MiSeq Reagent Kit v3 (150-cycle), MS-102-3001\n\n\n\nseq_center (type=string)\n\nName of facility where sequencing was performed (lab, core facility, or company)\n\n\nExample\n\nCode        {\n            \"lib_kit\" : \"TruSeq i5/i7 barcode primers\",\n            \"lib_layout\" : \"paired-end\",\n            \"lib_screen\" : \"40 µL reaction containing 10 µL of bead purified digested product, 18μL of nuclease-free water, 8μL of 5X secondary PCR master mix, and 5 µL of 10 µM TruSeq i5/i7 barcode primers\",\n            \"nucl_acid_amp\" : \"https://www.paragongenomics.com/targeted-sequencing/amplicon-sequencing/cleanplex-ngs-amplicon-sequencing/\",\n            \"nucl_acid_date\" : \"2019-07-15\",\n            \"nucl_acid_ext\" : \"https://www.paragongenomics.com/targeted-sequencing/amplicon-sequencing/cleanplex-ngs-amplicon-sequencing/\",\n            \"pcr_cond\" : \"10 min at 95°C, 13 cycles for high density samples (or 15 cycles for low density samples) of 15 sec at 98°C and 75 sec at 60°C\",\n            \"seq_center\" : \"UCSF\",\n            \"seq_date\" : \"2019-07-15\",\n            \"seq_instrument\" : \"NextSeq 550 instrument\",\n            \"sequencing_info_id\" : \"Mozambique2018\"\n        }"
  },
  {
    "objectID": "format/FormatOverview.html#experimentinfo",
    "href": "format/FormatOverview.html#experimentinfo",
    "title": "PMO fields overview",
    "section": "ExperimentInfo",
    "text": "ExperimentInfo\nhttps://plasmogenepi.github.io/portable-microhaplotype-object/ExperimentInfo/\nRequired\n\nsequencing_info_id (type=string)\n\na unique identifier for this sequencing info\n\n\n\nspecimen_id (type=string)\n\nthe name of the specimen of a individual\n\n\n\npanel_id (type=string)\n\nname of the panel\n\n\n\nexperiment_sample_id (type=string)\n\na unique identifier for this sequence/amplification run on a specimen\n\n\nOptional\n\naccession (type=string)\n\nERA/SRA accession number for the sample if it was submitted\n\n\n\nplate_col (type=integer)\n\nthe column the specimen was in\n\n\n\nplate_name (type=string)\n\na name of plate the specimen was in\n\n\n\nplate_row (type=string)\n\nthe row the specimen was in\n\n\nExample\n\nCode        {\n            \"experiment_sample_id\" : \"8025874217\",\n            \"panel_id\" : \"heomev1\",\n            \"plate_col\" : 12,\n            \"plate_name\" : \"8\",\n            \"plate_row\" : \"C\",\n            \"sequencing_info_id\" : \"Mozambique2018\",\n            \"specimen_id\" : \"8025874217\"\n        },"
  },
  {
    "objectID": "format/FormatOverview.html#specimeninfo",
    "href": "format/FormatOverview.html#specimeninfo",
    "title": "PMO fields overview",
    "section": "SpecimenInfo",
    "text": "SpecimenInfo\nhttps://plasmogenepi.github.io/portable-microhaplotype-object/SpecimenInfo/\nRequired\n\nspecimen_id (type=string)\n\nthe name of the specimen of a individual\n\n\n\nsamp_taxon_id (type=integer)\n\nthe NCBI taxonomy number of the organism of interest\n\n\n\ncollection_date (type=string)\n\nthe date of the sample collection\n\n\n\ncollection_country (type=string)\n\nthe name of country collected in, would be the same as admin level 0\n\n\n\ncollector (type=string)\n\nthe name of the primary person managing the specimen\n\n\n\nsamp_store_loc (type=string)\n\nthe sample store site, address or facility name\n\n\n\nsamp_collect_device (type=string)\n\nthe way the sample was collected, e.g. whole blood, dried blood spot, etc\n\n\n\nproject_name (type=string)\n\na name of the project under which the sample is organized\n\n\nOptional\n\nalternate_identifiers (type=array)\n\na list of optional alternative names for the samples\n\n\n\ngeo_admin1 (type=string)\n\ngeographical admin level 1, the secondary large demarcation of a nation (nation = admin level 0)\n\n\n\ngeo_admin2 (type=string)\n\ngeographical admin level 2, the third large demarcation of a nation (nation = admin level 0)\n\n\n\ngeo_admin3 (type=string)\n\ngeographical admin level 3, the third large demarcation of a nation (nation = admin level 0)\n\n\n\nhost_taxon_id (type=integer)\n\noptional the NCBI taxonomy number of the host of the organism\n\n\n\nindividual_id (type=string)\n\nan identifier for the individual a specimen was collected from\n\n\n\nlat_lon (type=string)\n\nthe latitude and longitude of the collection site of the specimen\n\n\n\nparasite_density (type=integer)\n\nthe parasite density in microliters\n\n\n\nplate_col (type=integer)\n\nthe column the specimen was in\n\n\n\nplate_name (type=string)\n\na name of plate the specimen was in\n\n\n\nplate_row (type=string)\n\nthe row the specimen was in\n\n\n\nsample_comments (type=string)\n\nany additional comments about the sample\n\n\nExample\n\nCode        {\n            \"collection_country\" : \"Mozambique\",\n            \"collection_date\" : \"2018-06-07\",\n            \"collector\" : \"Greenhouse, Bryan\",\n            \"geo_admin3\" : \"Inhassoro\",\n            \"host_taxon_id\" : 1758,\n            \"lat_lon\" : \"-21.5535,35.1819\",\n            \"parasite_density\" : 477719.34375,\n            \"plate_col\" : 12,\n            \"plate_name\" : \"8\",\n            \"plate_row\" : \"C\",\n            \"project_name\" : \"MOZ2018\",\n            \"samp_collect_device\" : \"dried blood spot\",\n            \"samp_store_loc\" : \"UCSF Greenhouse Lab\",\n            \"samp_taxon_id\" : 5833,\n            \"specimen_id\" : \"8025874217\"\n        },"
  },
  {
    "objectID": "Tools_Installation/pmotools-python_installation.html",
    "href": "Tools_Installation/pmotools-python_installation.html",
    "title": "pmotools-python installation",
    "section": "",
    "text": "pmotools-python is a tool base for interacting with the PMO format file in python. It provides both code to include in your python package as well as a command line interface to run some basic scripts on PMO files.\n\npmotools-python code can be found on github https://github.com/PlasmoGenEpi/pmotools-python/tree/develop\n\nDownloading repo\n\nCodegit clone git@github.com:PlasmoGenEpi/pmotools-python.git\n\n\nCurrently (as 2024-10) majority of code is currently still in develop branch\n\nCodecd pmotools-python\ngit checkout develop\n\n\n\nTo set up environment that has all the python libraries install a env library is included and can be install/activated via conda or mamba\n\nCodeconda env create -f envs/pmotools-env.yml \n\nconda active pmotools\n\n\n\nFrom within repo can install with pip in a virtual environment\n\nCodepip install -e . \n\n\n\npmotools-python can be included in python scripts but also there is a command line interface that includes several utilities that uses the code base, this interface can be included by including the scripts directory in your PATH or by calling the script directory\n\nCode# navigate to git directory\ncd pmotools-python\n\n##  add to path (must be done when within the git directory, or replace $(pwd) with the full path nmae to the git repo\nexport PATH=\"$(pwd)/scripts:$PATH\"\n\n\n\nTo enable bash auto-completion for pmotools-runner.py script located in the scripts directory mentioned above, add the following to your ~/.bash_completion and make sure it’s being loaded as part of your .bashrc and/or ~/.bash_profile (on MacOS) or ~/.profile (on ubuntu)\n\nCode_comp_pmotools_runner()\n{\n    local cur prev opts base\n    COMPREPLY=()\n    cur=\"${COMP_WORDS[COMP_CWORD]}\"\n    prev=\"${COMP_WORDS[COMP_CWORD-1]}\"\n    if [[ $COMP_CWORD -lt 2 ]] ; then\n        opts=$(for x in `${COMP_WORDS[0]} | grep \"^\\s.*-\" | sed 's/ -.*//g' | tr -d '[:blank:]'`; do echo ${x} ; done )\n        COMPREPLY=($(compgen -W \"${opts}\" -- ${cur}))\n    elif [[ ${cur} == -* ]]; then\n        opts=$(for x in `${COMP_WORDS[0]} ${COMP_WORDS[1]} -h | grep \" -\" | sed \"s/^. *-/-/g\" | sed \"s/   .*//g\" | sed \"s/, / /g\"`; do echo ${x} ; done )\n        COMPREPLY=($(compgen -W \"${opts}\" -- ${cur}))\n    else\n        _filedir\n    fi\n   return 0\n}\n\n\ncomplete -F _comp_pmotools_runner pmotools-runner.py\n\n\nThe above can also be found within the repo in the etc/ folder."
  },
  {
    "objectID": "Tools_Installation/pmotools-python_installation.html#installation",
    "href": "Tools_Installation/pmotools-python_installation.html#installation",
    "title": "pmotools-python installation",
    "section": "",
    "text": "pmotools-python code can be found on github https://github.com/PlasmoGenEpi/pmotools-python/tree/develop\n\nDownloading repo\n\nCodegit clone git@github.com:PlasmoGenEpi/pmotools-python.git\n\n\nCurrently (as 2024-10) majority of code is currently still in develop branch\n\nCodecd pmotools-python\ngit checkout develop\n\n\n\nTo set up environment that has all the python libraries install a env library is included and can be install/activated via conda or mamba\n\nCodeconda env create -f envs/pmotools-env.yml \n\nconda active pmotools\n\n\n\nFrom within repo can install with pip in a virtual environment\n\nCodepip install -e . \n\n\n\npmotools-python can be included in python scripts but also there is a command line interface that includes several utilities that uses the code base, this interface can be included by including the scripts directory in your PATH or by calling the script directory\n\nCode# navigate to git directory\ncd pmotools-python\n\n##  add to path (must be done when within the git directory, or replace $(pwd) with the full path nmae to the git repo\nexport PATH=\"$(pwd)/scripts:$PATH\"\n\n\n\nTo enable bash auto-completion for pmotools-runner.py script located in the scripts directory mentioned above, add the following to your ~/.bash_completion and make sure it’s being loaded as part of your .bashrc and/or ~/.bash_profile (on MacOS) or ~/.profile (on ubuntu)\n\nCode_comp_pmotools_runner()\n{\n    local cur prev opts base\n    COMPREPLY=()\n    cur=\"${COMP_WORDS[COMP_CWORD]}\"\n    prev=\"${COMP_WORDS[COMP_CWORD-1]}\"\n    if [[ $COMP_CWORD -lt 2 ]] ; then\n        opts=$(for x in `${COMP_WORDS[0]} | grep \"^\\s.*-\" | sed 's/ -.*//g' | tr -d '[:blank:]'`; do echo ${x} ; done )\n        COMPREPLY=($(compgen -W \"${opts}\" -- ${cur}))\n    elif [[ ${cur} == -* ]]; then\n        opts=$(for x in `${COMP_WORDS[0]} ${COMP_WORDS[1]} -h | grep \" -\" | sed \"s/^. *-/-/g\" | sed \"s/   .*//g\" | sed \"s/, / /g\"`; do echo ${x} ; done )\n        COMPREPLY=($(compgen -W \"${opts}\" -- ${cur}))\n    else\n        _filedir\n    fi\n   return 0\n}\n\n\ncomplete -F _comp_pmotools_runner pmotools-runner.py\n\n\nThe above can also be found within the repo in the etc/ folder."
  },
  {
    "objectID": "format/FormatExample.html#from-pf7-data-for-the-same-panel-above",
    "href": "format/FormatExample.html#from-pf7-data-for-the-same-panel-above",
    "title": "PMO Examples",
    "section": "From Pf7+ data for the same panel above",
    "text": "From Pf7+ data for the same panel above\nGlobal data microhaplotypes were constructed by PathWeaver for the same targeted amplicon panel above. This includes approximately 1900 samples.\n\nPathWeaverHeome1_PMO.json.gz"
  },
  {
    "objectID": "References.html",
    "href": "References.html",
    "title": "References",
    "section": "",
    "text": "Crystal-Ornelas, Robert, Charuleka Varadharajan, Dylan O’Ryan, Kathleen Beilsmith, Benjamin Bond-Lamberty, Kristin Boye, Madison Burrus, et al. 2022. “Enabling FAIR Data in Earth and Environmental Science with Community-Centric (Meta)data Reporting Formats.” Sci Data 9 (1): 700.\n\n\nOldoni, Fabio, Kenneth K Kidd, and Daniele Podini. 2019. “Microhaplotypes in Forensic Genetics.” Forensic Sci. Int. Genet. 38 (January): 54–69.\n\n\n“SRA Metadata and Submission Overview.” n.d. https://www.ncbi.nlm.nih.gov/sra/docs/submitmeta/.\n\n\nTessema, Sofonias K, Nicholas J Hathaway, Noam B Teyssier, Maxwell Murphy, Anna Chen, Ozkan Aydemir, Elias M Duarte, et al. 2022. “Sensitive, Highly Multiplexed Sequencing of Microhaplotypes from the Plasmodium Falciparum Heterozygome.” J. Infect. Dis. 225 (April): 1227–37.\n\n\nVangay Pajau, Burgin Josephine, Johnston Anjanette, Beck Kristen L., Berrios Daniel C., Blumberg Kai, Canon Shane, et al. 2021. “Microbiome Metadata Standards: Report of the National Microbiome Data Collaborative’s Workshop and Follow-On Activities.” mSystems 6 (1): e01194–20.\n\n\nWeisenhorn, Pamela, and Kathleen Beilsmith. 2022. “ESS-DIVE Reporting Format for Amplicon Abundance Table.” Environmental System Science Data Infrastructure for a Virtual Ecosystem; Environmental Systems Science Data Infrastructure for a Virtual Ecosystem (ESS-DIVE).\n\n\nYilmaz, Pelin, Renzo Kottmann, Dawn Field, Rob Knight, James R Cole, Linda Amaral-Zettler, Jack A Gilbert, et al. 2011. “Minimum Information about a Marker Gene Sequence (MIMARKS) and Minimum Information about Any (x) Sequence (MIxS) Specifications.” Nat. Biotechnol. 29 (5): 415–20."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Portable Microhaplotype Object (PMO)",
    "section": "",
    "text": "Website describing Portable Microhaplotype Object development"
  },
  {
    "objectID": "index.html#introduction",
    "href": "index.html#introduction",
    "title": "Portable Microhaplotype Object (PMO)",
    "section": "Introduction",
    "text": "Introduction\nAmplicon can be defined as a piece of DNA/RNA that has been amplified. When referring to amplicon data though we are referring to targeted amplicon data which is when a specific target of interest has been amplified by a set of primers and sequenced from a set of samples. Data from an amplicon can be referred to a microhaplotype (as opposed to a full haplotype which would be a full chromosome, a microhaplotype typical covers more than 1 variant and is approximately &lt;=300bp, which is it’s first definition(Oldoni, Kidd, and Podini 2019) but doesn’t have to meet those criteria precisely)"
  },
  {
    "objectID": "index.html#goals",
    "href": "index.html#goals",
    "title": "Portable Microhaplotype Object (PMO)",
    "section": "Goals",
    "text": "Goals\nTargeted amplicon sequencing has been a data analysis technique that has been well established and made most popular by microbiome analysis where a piece of 16S rRNA is amplified to help classify a microbiome mixture by defining taxon data and abundance.\nThe goal of a developing a amplicon file format, especially with Plasmodium in mind, is easing the comparison between experimental runs within and across labs."
  },
  {
    "objectID": "index.html#sources-of-data",
    "href": "index.html#sources-of-data",
    "title": "Portable Microhaplotype Object (PMO)",
    "section": "Sources of data",
    "text": "Sources of data\nData can be generated by targeted amplicon sequencing experiments or by doing local assembly on WGS data."
  },
  {
    "objectID": "index.html#goals-of-file-format",
    "href": "index.html#goals-of-file-format",
    "title": "Portable Microhaplotype Object (PMO)",
    "section": "Goals of file format",
    "text": "Goals of file format\n\nHelp individual researchers / groups organize their data\nFormat for sharing and reporting data to aid in standardization, transparency, and reproducibility\nAlign downstream analysis tools so no need to reshape data differently for each application\nMake data publicly available for analysis\nFacilitate cross-study analysis and tools e.g. “next-malaria”"
  },
  {
    "objectID": "index.html#the-genomic-standards-consortium",
    "href": "index.html#the-genomic-standards-consortium",
    "title": "Portable Microhaplotype Object (PMO)",
    "section": "The Genomic Standards Consortium",
    "text": "The Genomic Standards Consortium\nThe Genomic Standards Consortium\n\nThe Genomic Standards Consortium (GSC) is an open-membership working body formed in September 2005. The aim of the GSC is making genomic data discoverable. The GSC enables genomic data integration, discovery and comparison through international community-driven standards.\n\nThey are listed under the findability, accessibility, interoperability, and reusability (FAIR) sharinghttps://fairsharing.org/GSC"
  },
  {
    "objectID": "index.html#mixs",
    "href": "index.html#mixs",
    "title": "Portable Microhaplotype Object (PMO)",
    "section": "MIxS",
    "text": "MIxS\nGSC have developed several standards in order to try to standardized the way we describe genomics/sequencing data and have developed what is called “Minimum Information about any (X) Sequence” (MIxS) specification\nhttps://github.com/GenomicsStandardsConsortium/mixs/\n\nWithout specific guidelines, most genomic, metagenomic and marker gene sequences in databases are sparsely annotated with the information required to guide data integration, comparative studies and knowledge generation. Even with complex keyword searches, it is currently impossible to reliably retrieve sequences that have originated from certain environments or particular locations on Earth—for example, all sequences from ‘soil’ or ‘freshwater lakes’ in a certain region of the world. Because public databases of the International Nucleotide Sequence Database Collaboration (INSDC; comprising DNA Data Bank of Japan (DDBJ), the European Nucleotide Archive (EBI-ENA) and GenBank depend on author-submitted information to enrich the value of sequence data sets, we argue that the only way to change the current practice is to establish a standard of reporting that requires contextual data to be deposited at the time of sequence submission. The adoption of such a standard would elevate the quality, accessibility and utility of information that can be collected from INSDC or any other data repository.\n\nMicrobial specific\nMicrobiome world has long had to deal with targeted amplicon analysis primarily on 16s RNA sub-unit and more recently on Multilocus sequence typing (MLST)\nESS-DIVE amplicon file formating\nAs such they have already developed some standards on creating a generalized targeted amplicon file, standards set by Environmental System Science Data Infrastructure for a Virtual Ecosystem (ESS-DIVE), https://github.com/ess-dive-community, https://ess-dive.lbl.gov/\nTheir standards try to follow closely with Minimum Information about any Sequence (MIxS) standards\nbiom amplicon file formatting\nOther considerations are also the biom format which is written in HDF5 to help handle storing data in binary format, this is used by QIME along with several other common bacterial genomics tools"
  },
  {
    "objectID": "pmotools-python-usages/pmotools-runner.html",
    "href": "pmotools-python-usages/pmotools-runner.html",
    "title": "Command line interface to pmotools-python with pmotools-runner.py",
    "section": "",
    "text": "See installation instruction page for how to install pmotools-python which comes with a command line interact called pmotools-runner.py\n\nCodepmotools-runner.py\n\n\n\n\npmotools v1.0.0 - A suite of tools for interacting with Portable Microhaplotype Object (pmo) file format\n\nAvailable functions are\nconvertors_to_json\n    text_meta_to_json_meta - Convert text file meta to JSON Meta\n    excel_meta_to_json_meta - Convert excel file meta to JSON Meta\n    microhaplotype_table_to_json_file - Convert microhaplotype table to JSON Meta\n    terra_amp_output_to_json - Convert terra output table to JSON seq table\nextractors_from_pmo\n    extract_pmo_with_selected_meta - Extract from PMO samples and associated haplotypes with selected meta\n    extract_pmo_with_select_specimen_ids - Extract from PMO specific samples from the specimens table\n    extract_pmo_with_select_experiment_sample_ids - Extract from PMO specific experiment sample ids from the experiment_info table\n    extract_pmo_with_select_targets - Extract from PMO specific targets\n    extract_allele_table - Extract allele tables which can be as used as input to such tools as dcifer or moire\nworking_with_multiple_pmos\n    combine_pmos - Combine multiple pmos of the same panel into a single pmo\nextract_basic_info_from_pmo\n    list_experiment_sample_ids_per_specimen_id - Each specimen_id can have multiple experiment_sample_ids, list out all in a PMO\n    list_specimen_meta_fields - List out the specimen meta fields in the specimen_info section\n    list_tar_amp_bioinformatics_info_ids - List out all the tar_amp_bioinformatics_info_ids in a PMO file\n    count_specimen_meta - Count the values of specific specimen meta fields in the specimen_info section\n    count_targets_per_sample - Count the number of targets per sample\n    count_samples_per_target - Count the number of samples per target"
  },
  {
    "objectID": "pmotools-python-usages/handling_multiple_pmos.html",
    "href": "pmotools-python-usages/handling_multiple_pmos.html",
    "title": "Handling multiple PMOs pmotools-python",
    "section": "",
    "text": "pmotools-runner.py combine_pmos\nCan download multiple PMOs here\nhttps://seekdeep.brown.edu/Portable_Microhaplotype_Object/format/moz2018_PMO.json.gz\nhttps://seekdeep.brown.edu/Portable_Microhaplotype_Object/format/PathWeaverHeome1_PMO.json.gz\n\nCodepmotools-runner.py combine_pmos --help\n\nusage: pmotools-runner.py combine_pmos [-h] --pmo_files PMO_FILES --output\n                                       OUTPUT [--overwrite]\n\noptions:\n  -h, --help            show this help message and exit\n  --pmo_files PMO_FILES\n                        a list of PMO files to combine into 1 PMO file, must\n                        be from same amplicon panel\n  --output OUTPUT       Output new combined PMO file\n  --overwrite           If output file exists, overwrite it\n\n\nThe list of PMO files can be given comma separated to thier relative paths from where you run the script or in a file where each line is a different file to combine\n\nCodecd example \n\nwget https://seekdeep.brown.edu/Portable_Microhaplotype_Object/format/moz2018_PMO.json.gz\nwget https://seekdeep.brown.edu/Portable_Microhaplotype_Object/format/PathWeaverHeome1_PMO.json.gz\n\n\npmotools-runner.py combine_pmos --pmo_files moz2018_PMO.json.gz,PathWeaverHeome1_PMO.json.gz --output combined_Heome1_PMO.json.gz --overwrite\n\n\nThe python code for combine_pmos script is below\n\n\nCode\npmotools-python/scripts/pmo_utils/combine_pmos.py\n\n#!/usr/bin/env python3\nimport gzip\nimport os, argparse, json\nfrom collections import defaultdict\n\nimport pandas as pd\n\nfrom pmotools.pmo_utils.PMOWriter import PMOWriter\nfrom pmotools.utils.small_utils import Utils\nfrom pmotools.pmo_utils.PMOReader import PMOReader\n\n\n\ndef parse_args_combine_pmos():\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--pmo_files', type=str, required=True, help='a list of PMO files to combine into 1 PMO file, must be from same amplicon panel')\n    parser.add_argument('--output', type=str, required=True, help='Output new combined PMO file')\n    parser.add_argument('--overwrite', action = 'store_true', help='If output file exists, overwrite it')\n\n    return parser.parse_args()\n\ndef combine_pmos():\n    args = parse_args_combine_pmos()\n\n    # set up output\n    args.output = PMOWriter.add_pmo_extension_as_needed(args.output, args.output.endswith(\".gz\"))\n    Utils.outputfile_check(args.output, args.overwrite)\n\n    # check if at least 2 PMO files supplied\n    pmo_files_list = Utils.parse_delimited_input_or_file(args.pmo_files, \",\")\n    if len(pmo_files_list) &lt; 2:\n        raise Exception(\"Only supplied \" + str(len(pmo_files_list)) + \" but multiple PMO files were expected\")\n\n    # read in the PMOs\n    pmos = PMOReader.read_in_pmos(pmo_files_list)\n\n    # combine PMOs\n    pmo_out = PMOReader.combine_multiple_pmos(pmos)\n\n    # write\n    PMOWriter.write_out_pmo(pmo_out, args.output, args.overwrite)\n\n\nif __name__ == \"__main__\":\n    combine_pmos()"
  },
  {
    "objectID": "pmotools-python-usages/extracting_allele_tables.html",
    "href": "pmotools-python-usages/extracting_allele_tables.html",
    "title": "Extracting allele tables using pmotools-python",
    "section": "",
    "text": "To extract allele table information from a PMO the command line interactive script with pmotools-runner.py extract_allele_table can be used\n\npmotools-runner.py extract_allele_table\n\nRequired arguments\n\n\n--file - the PMO file to extract from\n\n--bioid - the tar_amp_bioinformatics_info_id id to extract the data from\n\n--output - the output stub of the files to be created\n\n\nOptional arguments\n\nBy default only 3 fields are extracted by this extractor, 1) sampleID (experiment_sample_id), 2) locus (target_id), and 3) allele (microhaplotype_id) with those default column names. This can be controlled by --default_base_col_names and if you supply 3 comma separated values you can change the default header.\nYou can also add to the table any values from the other portions of the PMO file by using the following arguments\n\nadding fields arguments\n\n\n--specimen_info_meta_fields - Meta Fields if any to include from the specimen table\n\n--experiment_info_meta_fields - Meta Fields if any to include from the experiment table\n\n--microhap_fields - additional optional fields from the detected microhaplotype object to include\n\n--representative_haps_fields - additional optional fields from the detected representative object to include\n\n\n\nOther optional arguments have to do with the ouput file over writing and delimiter being used, use -h to see all arguments\n\nCodepmotools-runner.py extract_allele_table -h\n\nusage: pmotools-runner.py extract_allele_table [-h] --bioid BIOID --file FILE\n                                               [--delim DELIM] --output OUTPUT\n                                               [--overwrite]\n                                               [--allele_freqs_output ALLELE_FREQS_OUTPUT]\n                                               [--specimen_info_meta_fields SPECIMEN_INFO_META_FIELDS]\n                                               [--experiment_info_meta_fields EXPERIMENT_INFO_META_FIELDS]\n                                               [--microhap_fields MICROHAP_FIELDS]\n                                               [--representative_haps_fields REPRESENTATIVE_HAPS_FIELDS]\n                                               [--default_base_col_names DEFAULT_BASE_COL_NAMES]\n\noptions:\n  -h, --help            show this help message and exit\n  --bioid BIOID         bio ID to extract for\n  --file FILE           PMO file\n  --delim DELIM         the delimiter of the input text file, examples\n                        tab,comma\n  --output OUTPUT       Output allele table file name path\n  --overwrite           If output file exists, overwrite it\n  --allele_freqs_output ALLELE_FREQS_OUTPUT\n                        if also writing out allele frequencies, write to this\n                        file\n  --specimen_info_meta_fields SPECIMEN_INFO_META_FIELDS\n                        Meta Fields if any to include from the specimen table\n  --experiment_info_meta_fields EXPERIMENT_INFO_META_FIELDS\n                        Meta Fields if any to include from the experiment\n                        table\n  --microhap_fields MICROHAP_FIELDS\n                        additional optional fields from the detected\n                        microhaplotype object to include\n  --representative_haps_fields REPRESENTATIVE_HAPS_FIELDS\n                        additional optional fields from the detected\n                        representative object to include\n  --default_base_col_names DEFAULT_BASE_COL_NAMES\n                        default base column names, must be length 3\n\n\nThe python code for extract_allele_table script is below\n\n\nCode\npmotools-python/scripts/extractors_from_pmo/extract_allele_table.py\n\n#!/usr/bin/env python3\nimport argparse\n\nfrom pmotools.pmo_utils.PMOReader import PMOReader\nfrom pmotools.utils.small_utils import Utils\nfrom pmotools.pmo_utils.PMOChecker import PMOChecker\nfrom pmotools.pmo_utils.PMOExtractor import PMOExtractor\n\n\n\ndef parse_args_extract_for_allele_table():\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--bioid', type=str, required=True, help='bio ID to extract for')\n    parser.add_argument('--file', type=str, required=True, help='PMO file')\n    parser.add_argument('--delim', default=\"tab\", type=str, required=False, help='the delimiter of the input text file, examples tab,comma')\n    parser.add_argument('--output', type=str, required=True, help='Output allele table file name path')\n    parser.add_argument('--overwrite', action = 'store_true', help='If output file exists, overwrite it')\n    parser.add_argument('--allele_freqs_output',type=str, help='if also writing out allele frequencies, write to this file')\n\n    parser.add_argument('--specimen_info_meta_fields', type=str, required=False, help='Meta Fields if any to include from the specimen table')\n    parser.add_argument('--experiment_info_meta_fields', type=str, required=False, help='Meta Fields if any to include from the experiment table')\n    parser.add_argument('--microhap_fields', type=str, required=False, help='additional optional fields from the detected microhaplotype object to include')\n    parser.add_argument('--representative_haps_fields', type=str, required=False, help='additional optional fields from the detected representative object to include')\n    parser.add_argument('--default_base_col_names', type=str, required=False, default=\"sampleID,locus,allele\", help='default base column names, must be length 3')\n\n    return parser.parse_args()\n\ndef extract_for_allele_table():\n    args = parse_args_extract_for_allele_table()\n\n    output_delim, output_extension = Utils.process_delimiter_and_output_extension(args.delim, gzip=args.output.endswith('.gz'))\n\n    allele_per_sample_table_out_fnp = args.output if \"STDOUT\" == args.output else Utils.appendStrAsNeeded(args.output, output_extension)\n    Utils.inputOutputFileCheck(args.file, allele_per_sample_table_out_fnp, args.overwrite)\n\n    allele_freq_output = \"\"\n    if args.allele_freqs_output is not None:\n        allele_freq_output = Utils.appendStrAsNeeded(args.allele_freqs_output, output_extension)\n        Utils.inputOutputFileCheck(args.file, allele_freq_output, args.overwrite)\n\n    checker = PMOChecker()\n    pmodata = PMOReader.read_in_pmo(args.file)\n\n    checker.check_for_required_base_fields(pmodata)\n    checker.check_bioinformatics_ids_consistency(pmodata)\n    checker.check_for_bioinformatics_id(pmodata, args.bioid)\n\n    if args.specimen_info_meta_fields is not None:\n        args.specimen_info_meta_fields = Utils.parse_delimited_input_or_file(args.specimen_info_meta_fields, \",\")\n    if args.microhap_fields is not None:\n        args.microhap_fields = Utils.parse_delimited_input_or_file(args.microhap_fields, \",\")\n    if args.experiment_info_meta_fields is not None:\n        args.experiment_info_meta_fields = Utils.parse_delimited_input_or_file(args.experiment_info_meta_fields, \",\")\n    if args.representative_haps_fields is not None:\n        args.representative_haps_fields = Utils.parse_delimited_input_or_file(args.representative_haps_fields, \",\")\n\n    PMOExtractor.write_alleles_per_sample_table(pmodata, args.bioid, allele_per_sample_table_out_fnp,\n                                                 additional_specimen_infos_fields = args.specimen_info_meta_fields,\n                                                 additional_experiment_infos_fields = args.experiment_info_meta_fields,\n                                                 additional_microhap_fields = args.microhap_fields,\n                                                 additional_representative_infos_fields = args.representative_haps_fields,\n                                                 output_delimiter=output_delim,\n                                                 default_base_col_names=args.default_base_col_names.split(\",\"))\n    if args.allele_freqs_output is not None:\n        allele_counts, allele_freqs, target_totals = PMOExtractor.extract_allele_counts_freq_from_pmo(pmodata, args.bioid)\n        PMOExtractor.write_allele_freq_output(allele_freq_output, allele_freqs, output_delimiter=output_delim)\n\nif __name__ == \"__main__\":\n    extract_for_allele_table()\n\n\n\nCan download example PMOs here\n\nCodewget https://seekdeep.brown.edu/Portable_Microhaplotype_Object/format/moz2018_PMO.json.gz \n\nwget https://seekdeep.brown.edu/Portable_Microhaplotype_Object/format/PathWeaverHeome1_PMO.json.gz\n\n\n\nCodemkdir -p example\ncd example \n\n# default \npmotools-runner.py extract_allele_table --file moz2018_PMO.json.gz --bioid Mozambique2018-SeekDeep --output extraction --overwrite\n\n\n\nCodecd example \n\n# changing default column names  \npmotools-runner.py extract_allele_table --file moz2018_PMO.json.gz --bioid Mozambique2018-SeekDeep --output extraction --overwrite --default_base_col_names sample,target,hapid\n\n\nChanging the output file delimiter\n\nCodecd example \n\npmotools-runner.py extract_allele_table --file moz2018_PMO.json.gz --bioid Mozambique2018-SeekDeep --output extraction --overwrite --delim ,\n\n\nAdding on additional columns from the specimen_infos section\n\nCodecd example \n\n# adding other PMO fields \npmotools-runner.py extract_allele_table --file moz2018_PMO.json.gz --bioid Mozambique2018-SeekDeep --output STDOUT --specimen_info_meta_fields collection_country,parasite_density | head  \n\n\n\n\nsampleID    locus   allele  collection_country  parasite_density\n8025874217  t1  t1.2    Mozambique  477719.34375\n8025874217  t1  t1.0    Mozambique  477719.34375\n8025874217  t10 t10.0   Mozambique  477719.34375\n8025874217  t100    t100.05 Mozambique  477719.34375\n8025874217  t11 t11.09  Mozambique  477719.34375\n8025874217  t12 t12.1   Mozambique  477719.34375\n8025874217  t12 t12.2   Mozambique  477719.34375\n8025874217  t13 t13.5   Mozambique  477719.34375\n8025874217  t14 t14.00  Mozambique  477719.34375\n\n\nCan continue to add on more columns from other sections\n\nCodecd example \n\n# adding other PMO fields including seq field \npmotools-runner.py extract_allele_table --file moz2018_PMO.json.gz --bioid Mozambique2018-SeekDeep --output STDOUT --specimen_info_meta_fields collection_country,parasite_density --representative_haps_fields seq | head \n\n\n\n\nsampleID    locus   allele  collection_country  parasite_density    seq\n8025874217  t1  t1.2    Mozambique  477719.34375    AACTTTTTTTATTTTTTTTGTCAATAGATAAATGATCAATATTTTCTATATTTAATCTATCAAGTATTTTTATATATCTATTATTTCTTTCTTCGATGGATAAATTATATGAATCAATATCCTTTCTTTCATCAACAAACTTTTTTATTGTTAACTCCATTTTTTTATTTA\n8025874217  t1  t1.0    Mozambique  477719.34375    AACTTTTTTTATTTTTTTTGTCAATAGATAAATGATCAATATTTTCTATATTTAATCTATCAAGTATTTTTATATATCTATTATTTCTTTCTTCGATGGATAAATTATAAGAATCAATATCCTTTCTTTCATCAACAAACTTTTTTATTGTTAACTCCATTTTTTTATTTA\n8025874217  t10 t10.0   Mozambique  477719.34375    ACTTATGTTCATGAGCTAATTTCCCACAAATACTCCATAACGAACTTTTCATTTTATTAAATTTATCTCTCAAAAGAGAATGACTATAATGCCATATTAAATACATATCTTTCCTTTCTAATTTTCCTGGTAATTCTATTATCATTCTTTCTAAATCTTCTTCTGTAACTTTT\n8025874217  t100    t100.05 Mozambique  477719.34375    TCGTTTTGAATTGTTAGAATTTAAAATGACGGAGGATTGTTATACAAAAATGTGGTTTGATTTTATGATTGATTTTGGAATAGCTACAATGAATGAAAACGAACATACTAGATCTTTTTATGGCT\n8025874217  t11 t11.09  Mozambique  477719.34375    GAATTTTCTTTTTTATGACTTTCTTCTCCTTGTTCAGAAGCTTCTTTTTCATCCTTTTTTTCTGCTGCGTCAGATAAATTGGGGGAAGCACTTGAAGATTCATTTCCTCCAGGAGTATTACTAGTACTTACTCCTTCCACATTTGGTTTTTCTTCCCCTAGAATTCTCA\n8025874217  t12 t12.1   Mozambique  477719.34375    TACACATAAGAAAAAAAAAATTTATTTATTCTTACAAAAAGAATATAAAAACAAAATTTTGGGATTTATAAATTTTTATAAACATATAACACACAAAATAAAAAAGAAACAAGAAAATGTTCATGATAAAATCACTTTTTTAAAATGTCTAAAGGAACTCTTTTTTGTCACACATACAAATG\n8025874217  t12 t12.2   Mozambique  477719.34375    TACACATAAGAAAAAAAAAATTTATTTATTCTTACAAAAAGAATATAAAAACAAAATTTTGGGATTTATAAATTTTTATAAACATATAACACACAAAATAAAAAAGAAACAAGAAAATGTTCATGATAAAATCACTTTTTTAAAATGTCTAAAGGAACTCTTTTTTGTCACACATACAAATA\n8025874217  t13 t13.5   Mozambique  477719.34375    TAATTATGAAGACAGTCTCACGACTGCATGTTATATTGATGAAAACAAATCCGATTCATCCTATAAAACTGAAGAAGAAAATGTAAACTATAATAATAAAATGGGTAAACGCAAAAATTTA\n8025874217  t14 t14.00  Mozambique  477719.34375    ACTTTTTAACACTATCATTATAATTATGTCTTTTATTTTCATATTTTTCTTTATAATAATTTATATCCTTTAATTTTTCTTTCATCAAATTTAACCATTTATCATTTAAATTCTCTTTTTCCACAGCTCCAGCATTTTTATTTATATCATCTACAACTACATCTTCCTTCACATAATTATTTATATAAAAATTATTATCATCTA\n\n\n\nMOIRE is a program that can be used to estimate COI and other population estimates from a population. See it’s github for full usage.\n\nCodemkdir -p example\ncd example \n\n# default table is all moire needs \npmotools-runner.py extract_allele_table --file moz2018_PMO.json.gz --bioid Mozambique2018-SeekDeep --output extraction --overwrite\n\n\n\nCodedf &lt;- read.csv(\"example/extraction_allele_table.tsv\", sep = \"\\t\")\n\ndata &lt;- load_long_form_data(df)\n\n# With data in appropriate format, run MCMC as follows\nmcmc_results &lt;- moire::run_mcmc(data, is_missing = data$is_missing)\n\n\n\ndcifer is a program that can estimate IBD even from mixed infections. See it’s github for full usage\n\nCodemkdir -p example\ncd example \n\n# default \npmotools-runner.py extract_allele_table --file moz2018_PMO.json.gz --bioid Mozambique2018-SeekDeep --output extraction --overwrite --delim ,\n\n# dcifer can calculate allele frequencies if not provided or you can have extract_allele_table write them as well \npmotools-runner.py extract_allele_table --file moz2018_PMO.json.gz --bioid Mozambique2018-SeekDeep --output extraction --overwrite --allele_freqs_output allele_freqs_extraction --delim ,\n\n\n\nCodedsmp &lt;- readDat(\"example/extraction_allele_table.csv\", svar = \"sampleID\", lvar = \"locus\", avar = \"allele\")\n\nlrank &lt;- 2\ncoi   &lt;- getCOI(dsmp, lrank = lrank)\n\nafreq &lt;- calcAfreq(dsmp, coi, tol = 1e-5) \n\ndres0 &lt;- ibdDat(dsmp, coi, afreq, pval = TRUE, confint = TRUE, rnull = 0, \n                alpha = 0.05, nr = 1e3)"
  },
  {
    "objectID": "pmotools-python-usages/extracting_allele_tables.html#creating-output-for-moire",
    "href": "pmotools-python-usages/extracting_allele_tables.html#creating-output-for-moire",
    "title": "Extracting allele tables using pmotools-python",
    "section": "",
    "text": "MOIRE is a program that can be used to estimate COI and other population estimates from a population. See it’s github for full usage.\n\nCodemkdir -p example\ncd example \n\n# default table is all moire needs \npmotools-runner.py extract_allele_table --file moz2018_PMO.json.gz --bioid Mozambique2018-SeekDeep --output extraction --overwrite\n\n\n\nCodedf &lt;- read.csv(\"example/extraction_allele_table.tsv\", sep = \"\\t\")\n\ndata &lt;- load_long_form_data(df)\n\n# With data in appropriate format, run MCMC as follows\nmcmc_results &lt;- moire::run_mcmc(data, is_missing = data$is_missing)"
  },
  {
    "objectID": "pmotools-python-usages/extracting_allele_tables.html#creating-output-for-dcifer",
    "href": "pmotools-python-usages/extracting_allele_tables.html#creating-output-for-dcifer",
    "title": "Extracting allele tables using pmotools-python",
    "section": "",
    "text": "dcifer is a program that can estimate IBD even from mixed infections. See it’s github for full usage\n\nCodemkdir -p example\ncd example \n\n# default \npmotools-runner.py extract_allele_table --file moz2018_PMO.json.gz --bioid Mozambique2018-SeekDeep --output extraction --overwrite --delim ,\n\n# dcifer can calculate allele frequencies if not provided or you can have extract_allele_table write them as well \npmotools-runner.py extract_allele_table --file moz2018_PMO.json.gz --bioid Mozambique2018-SeekDeep --output extraction --overwrite --allele_freqs_output allele_freqs_extraction --delim ,\n\n\n\nCodedsmp &lt;- readDat(\"example/extraction_allele_table.csv\", svar = \"sampleID\", lvar = \"locus\", avar = \"allele\")\n\nlrank &lt;- 2\ncoi   &lt;- getCOI(dsmp, lrank = lrank)\n\nafreq &lt;- calcAfreq(dsmp, coi, tol = 1e-5) \n\ndres0 &lt;- ibdDat(dsmp, coi, afreq, pval = TRUE, confint = TRUE, rnull = 0, \n                alpha = 0.05, nr = 1e3)"
  },
  {
    "objectID": "pmotools-python-usages/subsetting_from_PMO.html",
    "href": "pmotools-python-usages/subsetting_from_PMO.html",
    "title": "Subsetting from a PMO using pmotools-python",
    "section": "",
    "text": "There may be some instances were you want to subset a much larger PMO file into a smaller PMO file to focus only one a set of samples and/or targets. There are several ways of doing this.\n\nCan subset to only specific targets by using pmotools-runner.py extract_pmo_with_select_targets\n\nCodepmotools-runner.py extract_pmo_with_select_targets -h\n\nusage: pmotools-runner.py extract_pmo_with_select_targets [-h] --file FILE\n                                                          --output OUTPUT\n                                                          [--overwrite]\n                                                          [--verbose]\n                                                          --targets TARGETS\n\noptions:\n  -h, --help         show this help message and exit\n  --file FILE        PMO file\n  --output OUTPUT    Output json file path\n  --overwrite        If output file exists, overwrite it\n  --verbose          write out various messages about extraction\n  --targets TARGETS  Can either comma separated target_ids, or a plain text\n                     file where each line is a target_ids\n\n\nThe python code for extract_pmo_with_select_targets script is below\n\n\nCode\npmotools-python/scripts/extractors_from_pmo/extract_pmo_with_select_targets.py\n\n#!/usr/bin/env python3\nimport os, argparse, json\nimport sys\nfrom collections import defaultdict\n\nimport pandas as pd\n\nfrom pmotools.pmo_utils.PMOExtractor import PMOExtractor\nfrom pmotools.pmo_utils.PMOReader import PMOReader\nfrom pmotools.pmo_utils.PMOWriter import PMOWriter\nfrom pmotools.utils.small_utils import Utils\n\n\ndef parse_args_extract_pmo_with_select_targets():\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--file', type=str, required=True, help='PMO file')\n    parser.add_argument('--output', type=str, required=True, help='Output json file path')\n    parser.add_argument('--overwrite', action = 'store_true', help='If output file exists, overwrite it')\n    parser.add_argument('--verbose', action = 'store_true', help='write out various messages about extraction')\n    parser.add_argument('--targets', type=str, required=True, help='Can either comma separated target_ids, or a plain text file where each line is a target_ids')\n    return parser.parse_args()\n\ndef extract_pmo_with_select_targets():\n    args = parse_args_extract_pmo_with_select_targets()\n\n    # check files\n    Utils.inputOutputFileCheck(args.file, args.output, args.overwrite)\n\n    # parse target ids\n    all_target_ids = Utils.parse_delimited_input_or_file(args.targets)\n\n    # read in pmo\n    pmo = PMOReader.read_in_pmo(args.file)\n\n    # extract\n    pmo_out = PMOExtractor.extract_from_pmo_select_targets(pmo, all_target_ids)\n\n    # write out the extracted\n    args.output = PMOWriter.add_pmo_extension_as_needed(args.output, args.file.endswith('.gz') or args.output.endswith(\".gz\"))\n    PMOWriter.write_out_pmo(pmo_out, args.output, args.overwrite)\n\n\n\nif __name__ == \"__main__\":\n    extract_pmo_with_select_targets()\n\n\n\nYou can extract by supplies the desired targets with comma separated values on the command line\n\nCodecd example \n\npmotools-runner.py extract_pmo_with_select_targets --file moz2018_PMO.json.gz --targets t1,t20,t31  --output t1_t20_t31_moz2018_PMO.json.gz --overwrite\n\n\nYou can also provide a single column file where each line is a desired target\n\nCodecd example \n\necho -e \"t1\\nt20\\nt31\" &gt; select_targets.txt \npmotools-runner.py extract_pmo_with_select_targets --file moz2018_PMO.json.gz --targets select_targets.txt  --output t1_t20_t31_moz2018_PMO.json.gz --overwrite\n\necho -e \"t1\\nt20\\nt31\" | pmotools-runner.py extract_pmo_with_select_targets --file moz2018_PMO.json.gz --targets STDIN --output t1_t20_t31_moz2018_PMO.json.gz --overwrite\n\n\n\nYou can subset to just to just select specimen_id, each specimen can have several experiments associated with it, by supplying the specimen_id all associated experiments will also be pulled\nSimilar to above you can supply the specimen_ids either as comma separated values or in a plain text file where each line is a specimen_id\n\nCodepmotools-runner.py extract_pmo_with_select_specimen_ids -h\n\nusage: pmotools-runner.py extract_pmo_with_select_specimen_ids\n       [-h] --file FILE --output OUTPUT [--overwrite] [--verbose]\n       --specimen_ids SPECIMEN_IDS\n\noptions:\n  -h, --help            show this help message and exit\n  --file FILE           PMO file\n  --output OUTPUT       Output json file path\n  --overwrite           If output file exists, overwrite it\n  --verbose             write out various messages about extraction\n  --specimen_ids SPECIMEN_IDS\n                        Can either comma separated specimen_ids, or a plain\n                        text file where each line is a specimen_id\n\n\nThe python code for extract_pmo_with_select_specimen_ids script is below\n\n\nCode\npmotools-python/scripts/extractors_from_pmo/extract_pmo_with_select_specimen_ids.py\n\n#!/usr/bin/env python3\nimport os, argparse, json\nimport sys\nfrom collections import defaultdict\n\nimport pandas as pd\n\nfrom pmotools.pmo_utils.PMOExtractor import PMOExtractor\nfrom pmotools.pmo_utils.PMOReader import PMOReader\nfrom pmotools.pmo_utils.PMOWriter import PMOWriter\nfrom pmotools.utils.small_utils import Utils\n\n\ndef parse_args_extract_pmo_with_select_specimen_ids():\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--file', type=str, required=True, help='PMO file')\n    parser.add_argument('--output', type=str, required=True, help='Output json file path')\n    parser.add_argument('--overwrite', action = 'store_true', help='If output file exists, overwrite it')\n    parser.add_argument('--verbose', action = 'store_true', help='write out various messages about extraction')\n    parser.add_argument('--specimen_ids', type=str, required=True, help='Can either comma separated specimen_ids, or a plain text file where each line is a specimen_id')\n    return parser.parse_args()\n\ndef extract_pmo_with_select_specimen_ids():\n    args = parse_args_extract_pmo_with_select_specimen_ids()\n\n    # check files\n    Utils.inputOutputFileCheck(args.file, args.output, args.overwrite)\n\n    # parse specimen ids\n    all_specimen_ids = Utils.parse_delimited_input_or_file(args.specimen_ids)\n\n    # read in pmo\n    pmo = PMOReader.read_in_pmo(args.file)\n\n    # extract\n    pmo_out = PMOExtractor.extract_from_pmo_select_specimen_ids(pmo, all_specimen_ids)\n\n    # write out the extracted\n    args.output = PMOWriter.add_pmo_extension_as_needed(args.output, args.file.endswith('.gz') or args.output.endswith(\".gz\"))\n    PMOWriter.write_out_pmo(pmo_out, args.output, args.overwrite)\n\n\n\nif __name__ == \"__main__\":\n    extract_pmo_with_select_specimen_ids()\n\n\n\n\nCodecd example \n\npmotools-runner.py extract_pmo_with_select_specimen_ids --specimen_ids 8025874217,8025875146,8034209589 --file moz2018_PMO.json.gz --output 8025874217_8025875146_8034209589_moz2018_PMO.json.gz --overwrite\n\necho -e \"8025874217\\n8025875146\\n8034209589\" &gt; select_specimen_ids.txt \n\npmotools-runner.py extract_pmo_with_select_specimen_ids --specimen_ids select_specimen_ids.txt --file moz2018_PMO.json.gz --output 8025874217_8025875146_8034209589_moz2018_PMO.json.gz --overwrite\n\necho -e \"8025874217\\n8025875146\\n8034209589\" | pmotools-runner.py extract_pmo_with_select_specimen_ids --specimen_ids STDIN --file moz2018_PMO.json.gz --output 8025874217_8025875146_8034209589_moz2018_PMO.json.gz --overwrite\n\n\n\nIf you want just specific experiment_sample_id you can supply those instead too\nSimilar to above you can supply the experiment_sample_ids either as comma separated values or in a plain text file where each line is a experiment_sample_id or from standard in (STDIN)\n\nCodepmotools-runner.py extract_pmo_with_select_experiment_sample_ids -h\n\nusage: pmotools-runner.py extract_pmo_with_select_experiment_sample_ids\n       [-h] --file FILE --output OUTPUT [--overwrite] [--verbose]\n       --experiment_sample_ids EXPERIMENT_SAMPLE_IDS\n\noptions:\n  -h, --help            show this help message and exit\n  --file FILE           PMO file\n  --output OUTPUT       Output json file path\n  --overwrite           If output file exists, overwrite it\n  --verbose             write out various messages about extraction\n  --experiment_sample_ids EXPERIMENT_SAMPLE_IDS\n                        Can either comma separated experiment_sample_ids, or a\n                        plain text file where each line is a\n                        experiment_sample_id\n\n\nThe python code for extract_pmo_with_select_experiment_sample_ids script is below\n\n\nCode\npmotools-python/scripts/extractors_from_pmo/extract_pmo_with_select_experiment_sample_ids.py\n\n#!/usr/bin/env python3\nimport os, argparse, json\nimport sys\nfrom collections import defaultdict\n\nimport pandas as pd\n\nfrom pmotools.pmo_utils.PMOExtractor import PMOExtractor\nfrom pmotools.pmo_utils.PMOReader import PMOReader\nfrom pmotools.pmo_utils.PMOWriter import PMOWriter\nfrom pmotools.utils.small_utils import Utils\n\n\ndef parse_args_extract_pmo_with_select_experiment_sample_ids():\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--file', type=str, required=True, help='PMO file')\n    parser.add_argument('--output', type=str, required=True, help='Output json file path')\n    parser.add_argument('--overwrite', action = 'store_true', help='If output file exists, overwrite it')\n    parser.add_argument('--verbose', action = 'store_true', help='write out various messages about extraction')\n    parser.add_argument('--experiment_sample_ids', type=str, required=True, help='Can either comma separated experiment_sample_ids, or a plain text file where each line is a experiment_sample_id')\n    return parser.parse_args()\n\ndef extract_pmo_with_select_experiment_sample_ids():\n    args = parse_args_extract_pmo_with_select_experiment_sample_ids()\n\n    # check files\n    Utils.inputOutputFileCheck(args.file, args.output, args.overwrite)\n\n    # parse specimen ids\n    all_experiment_sample_ids = Utils.parse_delimited_input_or_file(args.experiment_sample_ids)\n\n    # read in pmo\n    pmo = PMOReader.read_in_pmo(args.file)\n\n    # extract\n    pmo_out = PMOExtractor.extract_from_pmo_select_experiment_sample_ids(pmo, all_experiment_sample_ids)\n\n    # write out the extracted\n    args.output = PMOWriter.add_pmo_extension_as_needed(args.output, args.file.endswith('.gz') or args.output.endswith(\".gz\"))\n    PMOWriter.write_out_pmo(pmo_out, args.output, args.overwrite)\n\n\n\nif __name__ == \"__main__\":\n    extract_pmo_with_select_experiment_sample_ids()\n\n\n\n\nCodecd example \n\npmotools-runner.py extract_pmo_with_select_experiment_sample_ids --experiment_sample_ids 8025875029,8034209834,8034209115 --file moz2018_PMO.json.gz --output 8025875029_8034209834_8034209115_moz2018_PMO.json.gz --overwrite\n\necho -e \"8025875029\\n8034209834\\n8034209115\" &gt; select_experiment_sample_ids.txt \n  \npmotools-runner.py extract_pmo_with_select_experiment_sample_ids --experiment_sample_ids select_experiment_sample_ids.txt --file moz2018_PMO.json.gz --output 8025875029_8034209834_8034209115_moz2018_PMO.json.gz --overwrite\n\n\necho -e \"8025875029\\n8034209834\\n8034209115\" | pmotools-runner.py extract_pmo_with_select_experiment_sample_ids --experiment_sample_ids STDIN --file moz2018_PMO.json.gz --output 8025875029_8034209834_8034209115_moz2018_PMO.json.gz --overwrite\n\n\n\nIf you want to get specific samples that match certain meta fields like specific collection_country or collection_date you can use ``\n\nCodepmotools-runner.py extract_pmo_with_selected_meta -h \n\nusage: pmotools-runner.py extract_pmo_with_selected_meta [-h] --file FILE\n                                                         --output OUTPUT\n                                                         [--overwrite]\n                                                         [--verbose]\n                                                         --metaFieldsValues\n                                                         METAFIELDSVALUES\n\noptions:\n  -h, --help            show this help message and exit\n  --file FILE           PMO file\n  --output OUTPUT       Output json file path\n  --overwrite           If output file exists, overwrite it\n  --verbose             write out various messages about extraction\n  --metaFieldsValues METAFIELDSVALUES\n                        Meta Fields to include, should either be a table with\n                        columns field, values (and optionally group) or\n                        supplied command line as\n                        field1=value1,value2,value3:field2=value1,value2\n\n\nThe python code for extract_pmo_with_selected_meta script is below\n\n\nCode\npmotools-python/scripts/extractors_from_pmo/extract_pmo_with_selected_meta.py\n\n#!/usr/bin/env python3\nimport os, argparse, json\nimport sys\nfrom collections import defaultdict\n\nimport pandas as pd\n\nfrom pmotools.pmo_utils.PMOExtractor import PMOExtractor\nfrom pmotools.pmo_utils.PMOReader import PMOReader\nfrom pmotools.pmo_utils.PMOWriter import PMOWriter\nfrom pmotools.utils.small_utils import Utils\n\n\ndef parse_args_extract_pmo_with_selected_meta():\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--file', type=str, required=True, help='PMO file')\n    parser.add_argument('--output', type=str, required=True, help='Output json file path')\n    parser.add_argument('--overwrite', action = 'store_true', help='If output file exists, overwrite it')\n    parser.add_argument('--verbose', action = 'store_true', help='write out various messages about extraction')\n    parser.add_argument('--metaFieldsValues', type=str, required=True, help='Meta Fields to include, should either be a table with columns field, values (and optionally group) or supplied command line as field1=value1,value2,value3:field2=value1,value2')\n    return parser.parse_args()\n\ndef extract_pmo_with_selected_meta():\n    args = parse_args_extract_pmo_with_selected_meta()\n\n    # check files\n    Utils.inputOutputFileCheck(args.file, args.output, args.overwrite)\n\n    # read in pmo\n    pmo = PMOReader.read_in_pmo(args.file)\n\n    # extract out of PMO\n    pmo_out, group_counts = PMOExtractor.extract_from_pmo_samples_with_meta_groupings(pmo, args.metaFieldsValues)\n\n    # write out the extracted\n    args.output = PMOWriter.add_pmo_extension_as_needed(args.output, args.file.endswith('.gz') or args.output.endswith(\".gz\"))\n    PMOWriter.write_out_pmo(pmo_out, args.output, args.overwrite)\n\n    if args.verbose:\n        sys.stdout.write(\"Extracted the following number of specimens per group:\" + \"\\n\")\n        group_counts.to_csv(sys.stdout, sep = \"\\t\", index = True)\n\nif __name__ == \"__main__\":\n    extract_pmo_with_selected_meta()\n\n\n\npmotools-runner.py extract_pmo_with_selected_meta is written to allow the extraction on multiple intersecting meta field requirments that can be either supplied in a file or with delimited on the command line\nYou may also want to know what current meta fields are present and how many samples in each. This can be done with pmotools-runner.py list_specimen_meta_fields and pmotools-runner.py count_specimen_meta\n\nCodecd example \nwget https://seekdeep.brown.edu/Portable_Microhaplotype_Object/format/PathWeaverHeome1_PMO.json.gz\n\n\n\nCodecd example \npmotools-runner.py list_specimen_meta_fields --file PathWeaverHeome1_PMO.json.gz\n\nfield   presentInSpecimensCount totalSpecimenCount\ncollection_country  19433   19433\ncollection_date 19433   19433\ncollector   19433   19433\ngeo_admin3  19433   19433\ngeo_continent   19433   19433\ngeo_region  19433   19433\ngeo_subRegion   19433   19433\nhost_taxon_id   19433   19433\nproject_name    19433   19433\nsamp_collect_device 19433   19433\nsamp_store_loc  19433   19433\nsamp_taxon_id   19433   19433\nspecimen_id 19433   19433\n\n\n\nCodecd example \npmotools-runner.py count_specimen_meta --file PathWeaverHeome1_PMO.json.gz  --meta_fields collection_country,collection_date | head -20\n\ncollection_country  collection_date specimensCount  specimensFreq   totalSpecimenCount\nBangladesh  2008    15  0.0007718828796377296   19433\nBangladesh  2009    16  0.000823341738280245    19433\nBangladesh  2012    51  0.002624401790768281    19433\nBangladesh  2015    508 0.026141100190397778    19433\nBangladesh  2016    816 0.041990428652292494    19433\nBangladesh  2017    12  0.0006175063037101837   19433\nBenin   2014    41  0.002109813204343128    19433\nBenin   2016    117 0.006020686461174291    19433\nBrazil  1980    1   5.145885864251531e-05   19433\nBrazil  2016    13  0.000668965162352699    19433\nBrazil  2017    5   0.00025729429321257654  19433\nBrazil  NA  1   5.145885864251531e-05   19433\nBurkina Faso    2008    58  0.002984613801265888    19433\nCambodia    1993    6   0.00030875315185509186  19433\nCambodia    2007    26  0.001337930324705398    19433\nCambodia    2008    50  0.0025729429321257654   19433\nCambodia    2009    66  0.0033962846704060105   19433\nCambodia    2010    182 0.009365512272937786    19433\nCambodia    2011    441 0.02269335666134925 19433\n\n\nExtracting on matching 1 meta field, below will extract just the samples that have collection_country=Bangladesh\n\nCodecd example \npmotools-runner.py extract_pmo_with_selected_meta  --file PathWeaverHeome1_PMO.json.gz --metaFieldsValues \"collection_country=Bangladesh\" --output Bangladesh_moz2018_PMO.json.gz   --overwrite\n\n\nIf you want to see how many samples were extracted can use --verbose\n\nCodecd example \npmotools-runner.py extract_pmo_with_selected_meta  --file PathWeaverHeome1_PMO.json.gz --metaFieldsValues \"collection_country=Bangladesh\" --output Bangladesh_moz2018_PMO.json.gz   --overwrite --verbose\n\nExtracted the following number of specimens per group:\ngroup   collection_country  count\n0   Bangladesh  1418\n\n\nCollecting more than 1 matching field separate by comma, for example to extract both Bangladesh,Benin\n\nCodecd example \n\npmotools-runner.py extract_pmo_with_selected_meta  --file PathWeaverHeome1_PMO.json.gz --metaFieldsValues \"collection_country=Bangladesh,Benin\" --output Bangladesh_Benin_moz2018_PMO.json.gz   --overwrite --verbose \n\nExtracted the following number of specimens per group:\ngroup   collection_country  count\n0   Bangladesh,Benin    1576\n\n\nCan add more extraction criteria meta, for example to extract samples with collection_country of Bangladesh or Benin and with collection_date of 2016\n\nCodecd example \n\npmotools-runner.py extract_pmo_with_selected_meta  --file PathWeaverHeome1_PMO.json.gz --metaFieldsValues \"collection_country=Bangladesh,Benin:collection_date=2016\" --output Bangladesh_Benin_2016_moz2018_PMO.json.gz   --overwrite --verbose \n\nExtracted the following number of specimens per group:\ngroup   collection_country  collection_date count\n0   Bangladesh,Benin    2016    933\n\n\nTo get more specific you can group meta field extraction criteria , for example if you wanted samples from Bangladesh from year 2015 but wanted Benin from year 2016 you can separate by a ;\n\nCodecd example \n\npmotools-runner.py extract_pmo_with_selected_meta  --file PathWeaverHeome1_PMO.json.gz --metaFieldsValues \"collection_country=Bangladesh:collection_date=2015;collection_country=Benin:collection_date=2016\" --output Bangladesh2015_Benin2016_moz2018_PMO.json.gz   --overwrite --verbose \n\nExtracted the following number of specimens per group:\ngroup   collection_country  collection_date count\n0   Bangladesh  2015    508\n1   Benin   2016    117\n\n\nRather than supplying with the command line a file can be created\n\nCodecd example \n\necho -e \"group\\tfield\\tvalues\" &gt; Bangladesh2015_Benin2016_extractionCriteria.tsv \necho -e \"Bangladesh2015\\tcollection_country\\tBangladesh\" &gt;&gt; Bangladesh2015_Benin2016_extractionCriteria.tsv \necho -e \"Bangladesh2015\\tcollection_date\\t2015\" &gt;&gt; Bangladesh2015_Benin2016_extractionCriteria.tsv \necho -e \"Benin2016\\tcollection_country\\tBenin\" &gt;&gt; Bangladesh2015_Benin2016_extractionCriteria.tsv \necho -e \"Benin2016\\tcollection_date\\t2016\" &gt;&gt; Bangladesh2015_Benin2016_extractionCriteria.tsv \n\n\npmotools-runner.py extract_pmo_with_selected_meta  --file PathWeaverHeome1_PMO.json.gz --metaFieldsValues Bangladesh2015_Benin2016_extractionCriteria.tsv --output Bangladesh2015_Benin2016_moz2018_PMO.json.gz   --overwrite --verbose \n\nExtracted the following number of specimens per group:\ngroup   collection_country  collection_date count\nBangladesh2015  Bangladesh  2015    508\nBenin2016   Benin   2016    117\n\n\n\nCodecd example \npmotools-runner.py extract_pmo_with_selected_meta  --file moz2018_PMO.json.gz --metaFieldsValues \"collection_country=Mozambique:geo_admin3=Inhassoro;collection_country=Mozambique:geo_admin3=Mandlakazi,Namaacha\" --output Mozambique_moz2018_PMO.json.gz  --verbose  --overwrite\n\nExtracted the following number of specimens per group:\ngroup   collection_country  geo_admin3  count\n0   Mozambique  Inhassoro   27\n1   Mozambique  Mandlakazi,Namaacha 54\n\n\n\nThe extraction methods also allow for STDOUT and STDIN piping for example\n\nCodecd example \n\necho -e \"8025875029\\n8034209834\\n8034209115\" | pmotools-runner.py extract_pmo_with_select_experiment_sample_ids --experiment_sample_ids STDIN --file moz2018_PMO.json.gz --output STDOUT | pmotools-runner.py extract_pmo_with_select_targets --file STDIN --targets t1,t20,t31  --output t1_t20_t31_8025875029_8034209834_8034209115_moz2018_PMO.json.gz --overwrite\n\n\nCan also pipe into other pmotools-runner.py functions like extracting allele tables\n\nCodecd example \n\necho -e \"8025875029\\n8034209834\\n8034209115\" | pmotools-runner.py extract_pmo_with_select_experiment_sample_ids --experiment_sample_ids STDIN --file moz2018_PMO.json.gz --output STDOUT | pmotools-runner.py extract_pmo_with_select_targets --file STDIN --targets t1,t20,t31  --output STDOUT | pmotools-runner.py extract_allele_table --file STDIN --bioid Mozambique2018-SeekDeep --output alleles_data_t1_t20_t31_8025875029_8034209834_8034209115_moz2018_PMO.tsv.gz --overwrite\n\n\nCan pipe final output to STDOUT as well for further processing\n\nCodecd example \n\necho -e \"8025875029\\n8034209834\\n8034209115\" | pmotools-runner.py extract_pmo_with_select_experiment_sample_ids --experiment_sample_ids STDIN --file moz2018_PMO.json.gz --output STDOUT | pmotools-runner.py extract_pmo_with_select_targets --file STDIN --targets t1,t20,t31  --output STDOUT | pmotools-runner.py extract_allele_table --file STDIN --bioid Mozambique2018-SeekDeep --output STDOUT  --specimen_info_meta_fields specimen_id,collection_country\n\nsampleID    locus   allele  specimen_id collection_country\n8025875029  t1  t1.0    8025875029  Mozambique\n8025875029  t1  t1.1    8025875029  Mozambique\n8025875029  t20 t20.3   8025875029  Mozambique\n8025875029  t20 t20.5   8025875029  Mozambique\n8025875029  t20 t20.4   8025875029  Mozambique\n8025875029  t31 t31.1   8025875029  Mozambique\n8025875029  t31 t31.3   8025875029  Mozambique\n8034209115  t1  t1.2    8034209115  Mozambique\n8034209115  t20 t20.4   8034209115  Mozambique\n8034209115  t20 t20.1   8034209115  Mozambique\n8034209115  t31 t31.1   8034209115  Mozambique\n8034209115  t31 t31.3   8034209115  Mozambique\n8034209834  t1  t1.0    8034209834  Mozambique\n8034209834  t20 t20.1   8034209834  Mozambique\n8034209834  t20 t20.0   8034209834  Mozambique\n8034209834  t31 t31.2   8034209834  Mozambique\n8034209834  t31 t31.0   8034209834  Mozambique"
  },
  {
    "objectID": "pmotools-python-usages/subsetting_from_PMO.html#subsetting-by-specific-targets",
    "href": "pmotools-python-usages/subsetting_from_PMO.html#subsetting-by-specific-targets",
    "title": "Subsetting from a PMO using pmotools-python",
    "section": "",
    "text": "Can subset to only specific targets by using pmotools-runner.py extract_pmo_with_select_targets\n\nCodepmotools-runner.py extract_pmo_with_select_targets -h\n\nusage: pmotools-runner.py extract_pmo_with_select_targets [-h] --file FILE\n                                                          --output OUTPUT\n                                                          [--overwrite]\n                                                          [--verbose]\n                                                          --targets TARGETS\n\noptions:\n  -h, --help         show this help message and exit\n  --file FILE        PMO file\n  --output OUTPUT    Output json file path\n  --overwrite        If output file exists, overwrite it\n  --verbose          write out various messages about extraction\n  --targets TARGETS  Can either comma separated target_ids, or a plain text\n                     file where each line is a target_ids\n\n\nThe python code for extract_pmo_with_select_targets script is below\n\n\nCode\npmotools-python/scripts/extractors_from_pmo/extract_pmo_with_select_targets.py\n\n#!/usr/bin/env python3\nimport os, argparse, json\nimport sys\nfrom collections import defaultdict\n\nimport pandas as pd\n\nfrom pmotools.pmo_utils.PMOExtractor import PMOExtractor\nfrom pmotools.pmo_utils.PMOReader import PMOReader\nfrom pmotools.pmo_utils.PMOWriter import PMOWriter\nfrom pmotools.utils.small_utils import Utils\n\n\ndef parse_args_extract_pmo_with_select_targets():\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--file', type=str, required=True, help='PMO file')\n    parser.add_argument('--output', type=str, required=True, help='Output json file path')\n    parser.add_argument('--overwrite', action = 'store_true', help='If output file exists, overwrite it')\n    parser.add_argument('--verbose', action = 'store_true', help='write out various messages about extraction')\n    parser.add_argument('--targets', type=str, required=True, help='Can either comma separated target_ids, or a plain text file where each line is a target_ids')\n    return parser.parse_args()\n\ndef extract_pmo_with_select_targets():\n    args = parse_args_extract_pmo_with_select_targets()\n\n    # check files\n    Utils.inputOutputFileCheck(args.file, args.output, args.overwrite)\n\n    # parse target ids\n    all_target_ids = Utils.parse_delimited_input_or_file(args.targets)\n\n    # read in pmo\n    pmo = PMOReader.read_in_pmo(args.file)\n\n    # extract\n    pmo_out = PMOExtractor.extract_from_pmo_select_targets(pmo, all_target_ids)\n\n    # write out the extracted\n    args.output = PMOWriter.add_pmo_extension_as_needed(args.output, args.file.endswith('.gz') or args.output.endswith(\".gz\"))\n    PMOWriter.write_out_pmo(pmo_out, args.output, args.overwrite)\n\n\n\nif __name__ == \"__main__\":\n    extract_pmo_with_select_targets()\n\n\n\nYou can extract by supplies the desired targets with comma separated values on the command line\n\nCodecd example \n\npmotools-runner.py extract_pmo_with_select_targets --file moz2018_PMO.json.gz --targets t1,t20,t31  --output t1_t20_t31_moz2018_PMO.json.gz --overwrite\n\n\nYou can also provide a single column file where each line is a desired target\n\nCodecd example \n\necho -e \"t1\\nt20\\nt31\" &gt; select_targets.txt \npmotools-runner.py extract_pmo_with_select_targets --file moz2018_PMO.json.gz --targets select_targets.txt  --output t1_t20_t31_moz2018_PMO.json.gz --overwrite\n\necho -e \"t1\\nt20\\nt31\" | pmotools-runner.py extract_pmo_with_select_targets --file moz2018_PMO.json.gz --targets STDIN --output t1_t20_t31_moz2018_PMO.json.gz --overwrite"
  },
  {
    "objectID": "pmotools-python-usages/subsetting_from_PMO.html#subsetting-by-specific-specimen_ids",
    "href": "pmotools-python-usages/subsetting_from_PMO.html#subsetting-by-specific-specimen_ids",
    "title": "Subsetting from a PMO using pmotools-python",
    "section": "",
    "text": "You can subset to just to just select specimen_id, each specimen can have several experiments associated with it, by supplying the specimen_id all associated experiments will also be pulled\nSimilar to above you can supply the specimen_ids either as comma separated values or in a plain text file where each line is a specimen_id\n\nCodepmotools-runner.py extract_pmo_with_select_specimen_ids -h\n\nusage: pmotools-runner.py extract_pmo_with_select_specimen_ids\n       [-h] --file FILE --output OUTPUT [--overwrite] [--verbose]\n       --specimen_ids SPECIMEN_IDS\n\noptions:\n  -h, --help            show this help message and exit\n  --file FILE           PMO file\n  --output OUTPUT       Output json file path\n  --overwrite           If output file exists, overwrite it\n  --verbose             write out various messages about extraction\n  --specimen_ids SPECIMEN_IDS\n                        Can either comma separated specimen_ids, or a plain\n                        text file where each line is a specimen_id\n\n\nThe python code for extract_pmo_with_select_specimen_ids script is below\n\n\nCode\npmotools-python/scripts/extractors_from_pmo/extract_pmo_with_select_specimen_ids.py\n\n#!/usr/bin/env python3\nimport os, argparse, json\nimport sys\nfrom collections import defaultdict\n\nimport pandas as pd\n\nfrom pmotools.pmo_utils.PMOExtractor import PMOExtractor\nfrom pmotools.pmo_utils.PMOReader import PMOReader\nfrom pmotools.pmo_utils.PMOWriter import PMOWriter\nfrom pmotools.utils.small_utils import Utils\n\n\ndef parse_args_extract_pmo_with_select_specimen_ids():\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--file', type=str, required=True, help='PMO file')\n    parser.add_argument('--output', type=str, required=True, help='Output json file path')\n    parser.add_argument('--overwrite', action = 'store_true', help='If output file exists, overwrite it')\n    parser.add_argument('--verbose', action = 'store_true', help='write out various messages about extraction')\n    parser.add_argument('--specimen_ids', type=str, required=True, help='Can either comma separated specimen_ids, or a plain text file where each line is a specimen_id')\n    return parser.parse_args()\n\ndef extract_pmo_with_select_specimen_ids():\n    args = parse_args_extract_pmo_with_select_specimen_ids()\n\n    # check files\n    Utils.inputOutputFileCheck(args.file, args.output, args.overwrite)\n\n    # parse specimen ids\n    all_specimen_ids = Utils.parse_delimited_input_or_file(args.specimen_ids)\n\n    # read in pmo\n    pmo = PMOReader.read_in_pmo(args.file)\n\n    # extract\n    pmo_out = PMOExtractor.extract_from_pmo_select_specimen_ids(pmo, all_specimen_ids)\n\n    # write out the extracted\n    args.output = PMOWriter.add_pmo_extension_as_needed(args.output, args.file.endswith('.gz') or args.output.endswith(\".gz\"))\n    PMOWriter.write_out_pmo(pmo_out, args.output, args.overwrite)\n\n\n\nif __name__ == \"__main__\":\n    extract_pmo_with_select_specimen_ids()\n\n\n\n\nCodecd example \n\npmotools-runner.py extract_pmo_with_select_specimen_ids --specimen_ids 8025874217,8025875146,8034209589 --file moz2018_PMO.json.gz --output 8025874217_8025875146_8034209589_moz2018_PMO.json.gz --overwrite\n\necho -e \"8025874217\\n8025875146\\n8034209589\" &gt; select_specimen_ids.txt \n\npmotools-runner.py extract_pmo_with_select_specimen_ids --specimen_ids select_specimen_ids.txt --file moz2018_PMO.json.gz --output 8025874217_8025875146_8034209589_moz2018_PMO.json.gz --overwrite\n\necho -e \"8025874217\\n8025875146\\n8034209589\" | pmotools-runner.py extract_pmo_with_select_specimen_ids --specimen_ids STDIN --file moz2018_PMO.json.gz --output 8025874217_8025875146_8034209589_moz2018_PMO.json.gz --overwrite"
  },
  {
    "objectID": "pmotools-python-usages/subsetting_from_PMO.html#subsetting-by-specific-experiment_sample_ids",
    "href": "pmotools-python-usages/subsetting_from_PMO.html#subsetting-by-specific-experiment_sample_ids",
    "title": "Subsetting from a PMO using pmotools-python",
    "section": "",
    "text": "If you want just specific experiment_sample_id you can supply those instead too\nSimilar to above you can supply the experiment_sample_ids either as comma separated values or in a plain text file where each line is a experiment_sample_id or from standard in (STDIN)\n\nCodepmotools-runner.py extract_pmo_with_select_experiment_sample_ids -h\n\nusage: pmotools-runner.py extract_pmo_with_select_experiment_sample_ids\n       [-h] --file FILE --output OUTPUT [--overwrite] [--verbose]\n       --experiment_sample_ids EXPERIMENT_SAMPLE_IDS\n\noptions:\n  -h, --help            show this help message and exit\n  --file FILE           PMO file\n  --output OUTPUT       Output json file path\n  --overwrite           If output file exists, overwrite it\n  --verbose             write out various messages about extraction\n  --experiment_sample_ids EXPERIMENT_SAMPLE_IDS\n                        Can either comma separated experiment_sample_ids, or a\n                        plain text file where each line is a\n                        experiment_sample_id\n\n\nThe python code for extract_pmo_with_select_experiment_sample_ids script is below\n\n\nCode\npmotools-python/scripts/extractors_from_pmo/extract_pmo_with_select_experiment_sample_ids.py\n\n#!/usr/bin/env python3\nimport os, argparse, json\nimport sys\nfrom collections import defaultdict\n\nimport pandas as pd\n\nfrom pmotools.pmo_utils.PMOExtractor import PMOExtractor\nfrom pmotools.pmo_utils.PMOReader import PMOReader\nfrom pmotools.pmo_utils.PMOWriter import PMOWriter\nfrom pmotools.utils.small_utils import Utils\n\n\ndef parse_args_extract_pmo_with_select_experiment_sample_ids():\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--file', type=str, required=True, help='PMO file')\n    parser.add_argument('--output', type=str, required=True, help='Output json file path')\n    parser.add_argument('--overwrite', action = 'store_true', help='If output file exists, overwrite it')\n    parser.add_argument('--verbose', action = 'store_true', help='write out various messages about extraction')\n    parser.add_argument('--experiment_sample_ids', type=str, required=True, help='Can either comma separated experiment_sample_ids, or a plain text file where each line is a experiment_sample_id')\n    return parser.parse_args()\n\ndef extract_pmo_with_select_experiment_sample_ids():\n    args = parse_args_extract_pmo_with_select_experiment_sample_ids()\n\n    # check files\n    Utils.inputOutputFileCheck(args.file, args.output, args.overwrite)\n\n    # parse specimen ids\n    all_experiment_sample_ids = Utils.parse_delimited_input_or_file(args.experiment_sample_ids)\n\n    # read in pmo\n    pmo = PMOReader.read_in_pmo(args.file)\n\n    # extract\n    pmo_out = PMOExtractor.extract_from_pmo_select_experiment_sample_ids(pmo, all_experiment_sample_ids)\n\n    # write out the extracted\n    args.output = PMOWriter.add_pmo_extension_as_needed(args.output, args.file.endswith('.gz') or args.output.endswith(\".gz\"))\n    PMOWriter.write_out_pmo(pmo_out, args.output, args.overwrite)\n\n\n\nif __name__ == \"__main__\":\n    extract_pmo_with_select_experiment_sample_ids()\n\n\n\n\nCodecd example \n\npmotools-runner.py extract_pmo_with_select_experiment_sample_ids --experiment_sample_ids 8025875029,8034209834,8034209115 --file moz2018_PMO.json.gz --output 8025875029_8034209834_8034209115_moz2018_PMO.json.gz --overwrite\n\necho -e \"8025875029\\n8034209834\\n8034209115\" &gt; select_experiment_sample_ids.txt \n  \npmotools-runner.py extract_pmo_with_select_experiment_sample_ids --experiment_sample_ids select_experiment_sample_ids.txt --file moz2018_PMO.json.gz --output 8025875029_8034209834_8034209115_moz2018_PMO.json.gz --overwrite\n\n\necho -e \"8025875029\\n8034209834\\n8034209115\" | pmotools-runner.py extract_pmo_with_select_experiment_sample_ids --experiment_sample_ids STDIN --file moz2018_PMO.json.gz --output 8025875029_8034209834_8034209115_moz2018_PMO.json.gz --overwrite"
  },
  {
    "objectID": "pmotools-python-usages/subsetting_from_PMO.html#subsetting-by-samples-within-specific-metafields",
    "href": "pmotools-python-usages/subsetting_from_PMO.html#subsetting-by-samples-within-specific-metafields",
    "title": "Subsetting from a PMO using pmotools-python",
    "section": "",
    "text": "If you want to get specific samples that match certain meta fields like specific collection_country or collection_date you can use ``\n\nCodepmotools-runner.py extract_pmo_with_selected_meta -h \n\nusage: pmotools-runner.py extract_pmo_with_selected_meta [-h] --file FILE\n                                                         --output OUTPUT\n                                                         [--overwrite]\n                                                         [--verbose]\n                                                         --metaFieldsValues\n                                                         METAFIELDSVALUES\n\noptions:\n  -h, --help            show this help message and exit\n  --file FILE           PMO file\n  --output OUTPUT       Output json file path\n  --overwrite           If output file exists, overwrite it\n  --verbose             write out various messages about extraction\n  --metaFieldsValues METAFIELDSVALUES\n                        Meta Fields to include, should either be a table with\n                        columns field, values (and optionally group) or\n                        supplied command line as\n                        field1=value1,value2,value3:field2=value1,value2\n\n\nThe python code for extract_pmo_with_selected_meta script is below\n\n\nCode\npmotools-python/scripts/extractors_from_pmo/extract_pmo_with_selected_meta.py\n\n#!/usr/bin/env python3\nimport os, argparse, json\nimport sys\nfrom collections import defaultdict\n\nimport pandas as pd\n\nfrom pmotools.pmo_utils.PMOExtractor import PMOExtractor\nfrom pmotools.pmo_utils.PMOReader import PMOReader\nfrom pmotools.pmo_utils.PMOWriter import PMOWriter\nfrom pmotools.utils.small_utils import Utils\n\n\ndef parse_args_extract_pmo_with_selected_meta():\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--file', type=str, required=True, help='PMO file')\n    parser.add_argument('--output', type=str, required=True, help='Output json file path')\n    parser.add_argument('--overwrite', action = 'store_true', help='If output file exists, overwrite it')\n    parser.add_argument('--verbose', action = 'store_true', help='write out various messages about extraction')\n    parser.add_argument('--metaFieldsValues', type=str, required=True, help='Meta Fields to include, should either be a table with columns field, values (and optionally group) or supplied command line as field1=value1,value2,value3:field2=value1,value2')\n    return parser.parse_args()\n\ndef extract_pmo_with_selected_meta():\n    args = parse_args_extract_pmo_with_selected_meta()\n\n    # check files\n    Utils.inputOutputFileCheck(args.file, args.output, args.overwrite)\n\n    # read in pmo\n    pmo = PMOReader.read_in_pmo(args.file)\n\n    # extract out of PMO\n    pmo_out, group_counts = PMOExtractor.extract_from_pmo_samples_with_meta_groupings(pmo, args.metaFieldsValues)\n\n    # write out the extracted\n    args.output = PMOWriter.add_pmo_extension_as_needed(args.output, args.file.endswith('.gz') or args.output.endswith(\".gz\"))\n    PMOWriter.write_out_pmo(pmo_out, args.output, args.overwrite)\n\n    if args.verbose:\n        sys.stdout.write(\"Extracted the following number of specimens per group:\" + \"\\n\")\n        group_counts.to_csv(sys.stdout, sep = \"\\t\", index = True)\n\nif __name__ == \"__main__\":\n    extract_pmo_with_selected_meta()\n\n\n\npmotools-runner.py extract_pmo_with_selected_meta is written to allow the extraction on multiple intersecting meta field requirments that can be either supplied in a file or with delimited on the command line\nYou may also want to know what current meta fields are present and how many samples in each. This can be done with pmotools-runner.py list_specimen_meta_fields and pmotools-runner.py count_specimen_meta\n\nCodecd example \nwget https://seekdeep.brown.edu/Portable_Microhaplotype_Object/format/PathWeaverHeome1_PMO.json.gz\n\n\n\nCodecd example \npmotools-runner.py list_specimen_meta_fields --file PathWeaverHeome1_PMO.json.gz\n\nfield   presentInSpecimensCount totalSpecimenCount\ncollection_country  19433   19433\ncollection_date 19433   19433\ncollector   19433   19433\ngeo_admin3  19433   19433\ngeo_continent   19433   19433\ngeo_region  19433   19433\ngeo_subRegion   19433   19433\nhost_taxon_id   19433   19433\nproject_name    19433   19433\nsamp_collect_device 19433   19433\nsamp_store_loc  19433   19433\nsamp_taxon_id   19433   19433\nspecimen_id 19433   19433\n\n\n\nCodecd example \npmotools-runner.py count_specimen_meta --file PathWeaverHeome1_PMO.json.gz  --meta_fields collection_country,collection_date | head -20\n\ncollection_country  collection_date specimensCount  specimensFreq   totalSpecimenCount\nBangladesh  2008    15  0.0007718828796377296   19433\nBangladesh  2009    16  0.000823341738280245    19433\nBangladesh  2012    51  0.002624401790768281    19433\nBangladesh  2015    508 0.026141100190397778    19433\nBangladesh  2016    816 0.041990428652292494    19433\nBangladesh  2017    12  0.0006175063037101837   19433\nBenin   2014    41  0.002109813204343128    19433\nBenin   2016    117 0.006020686461174291    19433\nBrazil  1980    1   5.145885864251531e-05   19433\nBrazil  2016    13  0.000668965162352699    19433\nBrazil  2017    5   0.00025729429321257654  19433\nBrazil  NA  1   5.145885864251531e-05   19433\nBurkina Faso    2008    58  0.002984613801265888    19433\nCambodia    1993    6   0.00030875315185509186  19433\nCambodia    2007    26  0.001337930324705398    19433\nCambodia    2008    50  0.0025729429321257654   19433\nCambodia    2009    66  0.0033962846704060105   19433\nCambodia    2010    182 0.009365512272937786    19433\nCambodia    2011    441 0.02269335666134925 19433\n\n\nExtracting on matching 1 meta field, below will extract just the samples that have collection_country=Bangladesh\n\nCodecd example \npmotools-runner.py extract_pmo_with_selected_meta  --file PathWeaverHeome1_PMO.json.gz --metaFieldsValues \"collection_country=Bangladesh\" --output Bangladesh_moz2018_PMO.json.gz   --overwrite\n\n\nIf you want to see how many samples were extracted can use --verbose\n\nCodecd example \npmotools-runner.py extract_pmo_with_selected_meta  --file PathWeaverHeome1_PMO.json.gz --metaFieldsValues \"collection_country=Bangladesh\" --output Bangladesh_moz2018_PMO.json.gz   --overwrite --verbose\n\nExtracted the following number of specimens per group:\ngroup   collection_country  count\n0   Bangladesh  1418\n\n\nCollecting more than 1 matching field separate by comma, for example to extract both Bangladesh,Benin\n\nCodecd example \n\npmotools-runner.py extract_pmo_with_selected_meta  --file PathWeaverHeome1_PMO.json.gz --metaFieldsValues \"collection_country=Bangladesh,Benin\" --output Bangladesh_Benin_moz2018_PMO.json.gz   --overwrite --verbose \n\nExtracted the following number of specimens per group:\ngroup   collection_country  count\n0   Bangladesh,Benin    1576\n\n\nCan add more extraction criteria meta, for example to extract samples with collection_country of Bangladesh or Benin and with collection_date of 2016\n\nCodecd example \n\npmotools-runner.py extract_pmo_with_selected_meta  --file PathWeaverHeome1_PMO.json.gz --metaFieldsValues \"collection_country=Bangladesh,Benin:collection_date=2016\" --output Bangladesh_Benin_2016_moz2018_PMO.json.gz   --overwrite --verbose \n\nExtracted the following number of specimens per group:\ngroup   collection_country  collection_date count\n0   Bangladesh,Benin    2016    933\n\n\nTo get more specific you can group meta field extraction criteria , for example if you wanted samples from Bangladesh from year 2015 but wanted Benin from year 2016 you can separate by a ;\n\nCodecd example \n\npmotools-runner.py extract_pmo_with_selected_meta  --file PathWeaverHeome1_PMO.json.gz --metaFieldsValues \"collection_country=Bangladesh:collection_date=2015;collection_country=Benin:collection_date=2016\" --output Bangladesh2015_Benin2016_moz2018_PMO.json.gz   --overwrite --verbose \n\nExtracted the following number of specimens per group:\ngroup   collection_country  collection_date count\n0   Bangladesh  2015    508\n1   Benin   2016    117\n\n\nRather than supplying with the command line a file can be created\n\nCodecd example \n\necho -e \"group\\tfield\\tvalues\" &gt; Bangladesh2015_Benin2016_extractionCriteria.tsv \necho -e \"Bangladesh2015\\tcollection_country\\tBangladesh\" &gt;&gt; Bangladesh2015_Benin2016_extractionCriteria.tsv \necho -e \"Bangladesh2015\\tcollection_date\\t2015\" &gt;&gt; Bangladesh2015_Benin2016_extractionCriteria.tsv \necho -e \"Benin2016\\tcollection_country\\tBenin\" &gt;&gt; Bangladesh2015_Benin2016_extractionCriteria.tsv \necho -e \"Benin2016\\tcollection_date\\t2016\" &gt;&gt; Bangladesh2015_Benin2016_extractionCriteria.tsv \n\n\npmotools-runner.py extract_pmo_with_selected_meta  --file PathWeaverHeome1_PMO.json.gz --metaFieldsValues Bangladesh2015_Benin2016_extractionCriteria.tsv --output Bangladesh2015_Benin2016_moz2018_PMO.json.gz   --overwrite --verbose \n\nExtracted the following number of specimens per group:\ngroup   collection_country  collection_date count\nBangladesh2015  Bangladesh  2015    508\nBenin2016   Benin   2016    117\n\n\n\nCodecd example \npmotools-runner.py extract_pmo_with_selected_meta  --file moz2018_PMO.json.gz --metaFieldsValues \"collection_country=Mozambique:geo_admin3=Inhassoro;collection_country=Mozambique:geo_admin3=Mandlakazi,Namaacha\" --output Mozambique_moz2018_PMO.json.gz  --verbose  --overwrite\n\nExtracted the following number of specimens per group:\ngroup   collection_country  geo_admin3  count\n0   Mozambique  Inhassoro   27\n1   Mozambique  Mandlakazi,Namaacha 54"
  },
  {
    "objectID": "pmotools-python-usages/subsetting_from_PMO.html#piping-together-extraction",
    "href": "pmotools-python-usages/subsetting_from_PMO.html#piping-together-extraction",
    "title": "Subsetting from a PMO using pmotools-python",
    "section": "",
    "text": "The extraction methods also allow for STDOUT and STDIN piping for example\n\nCodecd example \n\necho -e \"8025875029\\n8034209834\\n8034209115\" | pmotools-runner.py extract_pmo_with_select_experiment_sample_ids --experiment_sample_ids STDIN --file moz2018_PMO.json.gz --output STDOUT | pmotools-runner.py extract_pmo_with_select_targets --file STDIN --targets t1,t20,t31  --output t1_t20_t31_8025875029_8034209834_8034209115_moz2018_PMO.json.gz --overwrite\n\n\nCan also pipe into other pmotools-runner.py functions like extracting allele tables\n\nCodecd example \n\necho -e \"8025875029\\n8034209834\\n8034209115\" | pmotools-runner.py extract_pmo_with_select_experiment_sample_ids --experiment_sample_ids STDIN --file moz2018_PMO.json.gz --output STDOUT | pmotools-runner.py extract_pmo_with_select_targets --file STDIN --targets t1,t20,t31  --output STDOUT | pmotools-runner.py extract_allele_table --file STDIN --bioid Mozambique2018-SeekDeep --output alleles_data_t1_t20_t31_8025875029_8034209834_8034209115_moz2018_PMO.tsv.gz --overwrite\n\n\nCan pipe final output to STDOUT as well for further processing\n\nCodecd example \n\necho -e \"8025875029\\n8034209834\\n8034209115\" | pmotools-runner.py extract_pmo_with_select_experiment_sample_ids --experiment_sample_ids STDIN --file moz2018_PMO.json.gz --output STDOUT | pmotools-runner.py extract_pmo_with_select_targets --file STDIN --targets t1,t20,t31  --output STDOUT | pmotools-runner.py extract_allele_table --file STDIN --bioid Mozambique2018-SeekDeep --output STDOUT  --specimen_info_meta_fields specimen_id,collection_country\n\nsampleID    locus   allele  specimen_id collection_country\n8025875029  t1  t1.0    8025875029  Mozambique\n8025875029  t1  t1.1    8025875029  Mozambique\n8025875029  t20 t20.3   8025875029  Mozambique\n8025875029  t20 t20.5   8025875029  Mozambique\n8025875029  t20 t20.4   8025875029  Mozambique\n8025875029  t31 t31.1   8025875029  Mozambique\n8025875029  t31 t31.3   8025875029  Mozambique\n8034209115  t1  t1.2    8034209115  Mozambique\n8034209115  t20 t20.4   8034209115  Mozambique\n8034209115  t20 t20.1   8034209115  Mozambique\n8034209115  t31 t31.1   8034209115  Mozambique\n8034209115  t31 t31.3   8034209115  Mozambique\n8034209834  t1  t1.0    8034209834  Mozambique\n8034209834  t20 t20.1   8034209834  Mozambique\n8034209834  t20 t20.0   8034209834  Mozambique\n8034209834  t31 t31.2   8034209834  Mozambique\n8034209834  t31 t31.0   8034209834  Mozambique"
  }
]